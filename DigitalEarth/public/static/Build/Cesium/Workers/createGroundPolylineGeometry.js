/**
 * @license
 * Cesium - https://github.com/CesiumGS/cesium
 * Version 1.96
 *
 * Copyright 2011-2022 Cesium Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Columbus View (Pat. Pend.)
 *
 * Portions licensed separately.
 * See https://github.com/CesiumGS/cesium/blob/main/LICENSE.md for full licensing details.
 */
define(["./Transforms-99c89742","./Matrix4-d3db9505","./Check-436535f3","./defined-b681f02d","./Rectangle-0610a1c7","./Math-5b6faca9","./ArcType-f5af12f9","./arrayRemoveDuplicates-bbac3e0e","./ComponentDatatype-46a1cf7a","./EllipsoidGeodesic-bd79a412","./EllipsoidRhumbLine-65d4aeca","./EncodedCartesian3-e8f321af","./GeometryAttribute-ef6ca9ab","./IntersectionTests-3ac7f0c9","./Plane-172c23d7","./WebMercatorProjection-05e4c9ff","./Interval-49d6e8fc","./_commonjsHelpers-a32ac251","./combine-8b9ba6cb","./RequestType-e53aab71","./RuntimeError-14317824","./WebGLConstants-f100e3dd","./Matrix2-7384588e"],(function(e,t,a,n,i,r,s,o,l,c,u,C,p,d,h,g,f,m,w,y,M,T,E){"use strict";function _(t){t=n.defaultValue(t,n.defaultValue.EMPTY_OBJECT),this._ellipsoid=n.defaultValue(t.ellipsoid,i.Ellipsoid.WGS84),this._rectangle=n.defaultValue(t.rectangle,i.Rectangle.MAX_VALUE),this._projection=new e.GeographicProjection(this._ellipsoid),this._numberOfLevelZeroTilesX=n.defaultValue(t.numberOfLevelZeroTilesX,2),this._numberOfLevelZeroTilesY=n.defaultValue(t.numberOfLevelZeroTilesY,1)}Object.defineProperties(_.prototype,{ellipsoid:{get:function(){return this._ellipsoid}},rectangle:{get:function(){return this._rectangle}},projection:{get:function(){return this._projection}}}),_.prototype.getNumberOfXTilesAtLevel=function(e){return this._numberOfLevelZeroTilesX<<e},_.prototype.getNumberOfYTilesAtLevel=function(e){return this._numberOfLevelZeroTilesY<<e},_.prototype.rectangleToNativeRectangle=function(e,t){const a=r.CesiumMath.toDegrees(e.west),s=r.CesiumMath.toDegrees(e.south),o=r.CesiumMath.toDegrees(e.east),l=r.CesiumMath.toDegrees(e.north);return n.defined(t)?(t.west=a,t.south=s,t.east=o,t.north=l,t):new i.Rectangle(a,s,o,l)},_.prototype.tileXYToNativeRectangle=function(e,t,a,n){const i=this.tileXYToRectangle(e,t,a,n);return i.west=r.CesiumMath.toDegrees(i.west),i.south=r.CesiumMath.toDegrees(i.south),i.east=r.CesiumMath.toDegrees(i.east),i.north=r.CesiumMath.toDegrees(i.north),i},_.prototype.tileXYToRectangle=function(e,t,a,r){const s=this._rectangle,o=this.getNumberOfXTilesAtLevel(a),l=this.getNumberOfYTilesAtLevel(a),c=s.width/o,u=e*c+s.west,C=(e+1)*c+s.west,p=s.height/l,d=s.north-t*p,h=s.north-(t+1)*p;return n.defined(r)||(r=new i.Rectangle(u,h,C,d)),r.west=u,r.south=h,r.east=C,r.north=d,r},_.prototype.positionToTileXY=function(e,a,s){const o=this._rectangle;if(!i.Rectangle.contains(o,e))return;const l=this.getNumberOfXTilesAtLevel(a),c=this.getNumberOfYTilesAtLevel(a),u=o.width/l,C=o.height/c;let p=e.longitude;o.east<o.west&&(p+=r.CesiumMath.TWO_PI);let d=(p-o.west)/u|0;d>=l&&(d=l-1);let h=(o.north-e.latitude)/C|0;return h>=c&&(h=c-1),n.defined(s)?(s.x=d,s.y=h,s):new t.Cartesian2(d,h)};const O=new t.Cartesian3,b=new t.Cartesian3,P=new t.Cartographic,k=new t.Cartesian3,A=new t.Cartesian3,L=new e.BoundingSphere,S=new _,x=[new t.Cartographic,new t.Cartographic,new t.Cartographic,new t.Cartographic],I=new t.Cartesian2,N={};function R(e){t.Cartographic.fromRadians(e.east,e.north,0,x[0]),t.Cartographic.fromRadians(e.west,e.north,0,x[1]),t.Cartographic.fromRadians(e.east,e.south,0,x[2]),t.Cartographic.fromRadians(e.west,e.south,0,x[3]);let a=0,n=0,i=0,r=0;const s=N._terrainHeightsMaxLevel;let o;for(o=0;o<=s;++o){let e=!1;for(let t=0;t<4;++t){const a=x[t];if(S.positionToTileXY(a,o,I),0===t)i=I.x,r=I.y;else if(i!==I.x||r!==I.y){e=!0;break}}if(e)break;a=i,n=r}if(0!==o)return{x:a,y:n,level:o>s?s:o-1}}N.initialize=function(){let t=N._initPromise;return n.defined(t)||(t=e.Resource.fetchJson(e.buildModuleUrl("Assets/approximateTerrainHeights.json")).then((function(e){N._terrainHeights=e})),N._initPromise=t),t},N.getMinimumMaximumHeights=function(e,a){a=n.defaultValue(a,i.Ellipsoid.WGS84);const r=R(e);let s=N._defaultMinTerrainHeight,o=N._defaultMaxTerrainHeight;if(n.defined(r)){const l=`${r.level}-${r.x}-${r.y}`,c=N._terrainHeights[l];n.defined(c)&&(s=c[0],o=c[1]),a.cartographicToCartesian(i.Rectangle.northeast(e,P),O),a.cartographicToCartesian(i.Rectangle.southwest(e,P),b),t.Cartesian3.midpoint(b,O,k);const u=a.scaleToGeodeticSurface(k,A);if(n.defined(u)){const e=t.Cartesian3.distance(k,u);s=Math.min(s,-e)}else s=N._defaultMinTerrainHeight}return s=Math.max(N._defaultMinTerrainHeight,s),{minimumTerrainHeight:s,maximumTerrainHeight:o}},N.getBoundingSphere=function(t,a){a=n.defaultValue(a,i.Ellipsoid.WGS84);const r=R(t);let s=N._defaultMaxTerrainHeight;if(n.defined(r)){const e=`${r.level}-${r.x}-${r.y}`,t=N._terrainHeights[e];n.defined(t)&&(s=t[1])}const o=e.BoundingSphere.fromRectangle3D(t,a,0);return e.BoundingSphere.fromRectangle3D(t,a,s,L),e.BoundingSphere.union(o,L,o)},N._terrainHeightsMaxLevel=6,N._defaultMaxTerrainHeight=9e3,N._defaultMinTerrainHeight=-1e5,N._terrainHeights=void 0,N._initPromise=void 0,Object.defineProperties(N,{initialized:{get:function(){return n.defined(N._terrainHeights)}}});const D=[e.GeographicProjection,g.WebMercatorProjection],v=D.length,z=Math.cos(r.CesiumMath.toRadians(30)),H=Math.cos(r.CesiumMath.toRadians(150));function j(e){const t=(e=n.defaultValue(e,n.defaultValue.EMPTY_OBJECT)).positions;this.width=n.defaultValue(e.width,1),this._positions=t,this.granularity=n.defaultValue(e.granularity,9999),this.loop=n.defaultValue(e.loop,!1),this.arcType=n.defaultValue(e.arcType,s.ArcType.GEODESIC),this._ellipsoid=i.Ellipsoid.WGS84,this._projectionIndex=0,this._workerName="createGroundPolylineGeometry",this._scene3DOnly=!1}Object.defineProperties(j.prototype,{packedLength:{get:function(){return 1+3*this._positions.length+1+1+1+i.Ellipsoid.packedLength+1+1}}}),j.setProjectionAndEllipsoid=function(e,t){let a=0;for(let e=0;e<v;e++)if(t instanceof D[e]){a=e;break}e._projectionIndex=a,e._ellipsoid=t.ellipsoid};const B=new t.Cartesian3,G=new t.Cartesian3,V=new t.Cartesian3;function Y(e,a,n,i,r){const s=$(i,e,0,B),o=$(i,e,n,G),l=$(i,a,0,V),c=J(o,s,G),u=J(l,s,V);return t.Cartesian3.cross(u,c,r),t.Cartesian3.normalize(r,r)}const q=new t.Cartographic,F=new t.Cartesian3,X=new t.Cartesian3,W=new t.Cartesian3;function U(e,a,n,i,r,o,l,C,p,d,h){if(0===r)return;let g;o===s.ArcType.GEODESIC?g=new c.EllipsoidGeodesic(e,a,l):o===s.ArcType.RHUMB&&(g=new u.EllipsoidRhumbLine(e,a,l));const f=g.surfaceDistance;if(f<r)return;const m=Y(e,a,i,l,W),w=Math.ceil(f/r),y=f/w;let M=y;const T=w-1;let E=C.length;for(let e=0;e<T;e++){const e=g.interpolateUsingSurfaceDistance(M,q),a=$(l,e,n,F),r=$(l,e,i,X);t.Cartesian3.pack(m,C,E),t.Cartesian3.pack(a,p,E),t.Cartesian3.pack(r,d,E),h.push(e.latitude),h.push(e.longitude),E+=3,M+=y}}const Z=new t.Cartographic;function $(e,a,n,i){return t.Cartographic.clone(a,Z),Z.height=n,t.Cartographic.toCartesian(Z,e,i)}function J(e,a,n){return t.Cartesian3.subtract(e,a,n),t.Cartesian3.normalize(n,n),n}function Q(e,a,n,i){return i=J(e,a,i),i=t.Cartesian3.cross(i,n,i),i=t.Cartesian3.normalize(i,i),i=t.Cartesian3.cross(n,i,i)}j.pack=function(e,a,r){let s=n.defaultValue(r,0);const o=e._positions,l=o.length;a[s++]=l;for(let e=0;e<l;++e){const n=o[e];t.Cartesian3.pack(n,a,s),s+=3}return a[s++]=e.granularity,a[s++]=e.loop?1:0,a[s++]=e.arcType,i.Ellipsoid.pack(e._ellipsoid,a,s),s+=i.Ellipsoid.packedLength,a[s++]=e._projectionIndex,a[s++]=e._scene3DOnly?1:0,a},j.unpack=function(e,a,r){let s=n.defaultValue(a,0);const o=e[s++],l=new Array(o);for(let a=0;a<o;a++)l[a]=t.Cartesian3.unpack(e,s),s+=3;const c=e[s++],u=1===e[s++],C=e[s++],p=i.Ellipsoid.unpack(e,s);s+=i.Ellipsoid.packedLength;const d=e[s++],h=1===e[s++];return n.defined(r)||(r=new j({positions:l})),r._positions=l,r.granularity=c,r.loop=u,r.arcType=C,r._ellipsoid=p,r._projectionIndex=d,r._scene3DOnly=h,r};const K=new t.Cartesian3,ee=new t.Cartesian3,te=new t.Cartesian3,ae=new t.Cartesian3;function ne(e,a,n,i,s){const o=J(n,a,ae),l=Q(e,a,o,K),c=Q(i,a,o,ee);if(r.CesiumMath.equalsEpsilon(t.Cartesian3.dot(l,c),-1,r.CesiumMath.EPSILON5))return s=t.Cartesian3.cross(o,l,s),s=t.Cartesian3.normalize(s,s);s=t.Cartesian3.add(c,l,s),s=t.Cartesian3.normalize(s,s);const u=t.Cartesian3.cross(o,s,te);return t.Cartesian3.dot(c,u)<0&&(s=t.Cartesian3.negate(s,s)),s}const ie=h.Plane.fromPointNormal(t.Cartesian3.ZERO,t.Cartesian3.UNIT_Y),re=new t.Cartesian3,se=new t.Cartesian3,oe=new t.Cartesian3,le=new t.Cartesian3,ce=new t.Cartesian3,ue=new t.Cartesian3,Ce=new t.Cartographic,pe=new t.Cartographic,de=new t.Cartographic;j.createGeometry=function(a){const c=!a._scene3DOnly;let h=a.loop;const g=a._ellipsoid,f=a.granularity,m=a.arcType,w=new D[a._projectionIndex](g),y=1e3;let M,T;const E=a._positions,_=E.length;let O,b,P,k;2===_&&(h=!1);const A=new u.EllipsoidRhumbLine(void 0,void 0,g);let L,S,x;const I=[E[0]];for(T=0;T<_-1;T++)O=E[T],b=E[T+1],L=d.IntersectionTests.lineSegmentPlane(O,b,ie,ue),!n.defined(L)||t.Cartesian3.equalsEpsilon(L,O,r.CesiumMath.EPSILON7)||t.Cartesian3.equalsEpsilon(L,b,r.CesiumMath.EPSILON7)||(a.arcType===s.ArcType.GEODESIC?I.push(t.Cartesian3.clone(L)):a.arcType===s.ArcType.RHUMB&&(x=g.cartesianToCartographic(L,Ce).longitude,P=g.cartesianToCartographic(O,Ce),k=g.cartesianToCartographic(b,pe),A.setEndPoints(P,k),S=A.findIntersectionWithLongitude(x,de),L=g.cartographicToCartesian(S,ue),!n.defined(L)||t.Cartesian3.equalsEpsilon(L,O,r.CesiumMath.EPSILON7)||t.Cartesian3.equalsEpsilon(L,b,r.CesiumMath.EPSILON7)||I.push(t.Cartesian3.clone(L)))),I.push(b);h&&(O=E[_-1],b=E[0],L=d.IntersectionTests.lineSegmentPlane(O,b,ie,ue),!n.defined(L)||t.Cartesian3.equalsEpsilon(L,O,r.CesiumMath.EPSILON7)||t.Cartesian3.equalsEpsilon(L,b,r.CesiumMath.EPSILON7)||(a.arcType===s.ArcType.GEODESIC?I.push(t.Cartesian3.clone(L)):a.arcType===s.ArcType.RHUMB&&(x=g.cartesianToCartographic(L,Ce).longitude,P=g.cartesianToCartographic(O,Ce),k=g.cartesianToCartographic(b,pe),A.setEndPoints(P,k),S=A.findIntersectionWithLongitude(x,de),L=g.cartographicToCartesian(S,ue),!n.defined(L)||t.Cartesian3.equalsEpsilon(L,O,r.CesiumMath.EPSILON7)||t.Cartesian3.equalsEpsilon(L,b,r.CesiumMath.EPSILON7)||I.push(t.Cartesian3.clone(L)))));let R=I.length,v=new Array(R);for(T=0;T<R;T++){const e=t.Cartographic.fromCartesian(I[T],g);e.height=0,v[T]=e}if(v=o.arrayRemoveDuplicates(v,t.Cartographic.equalsEpsilon),R=v.length,R<2)return;const H=[],j=[],B=[],G=[];let V=re,q=se,F=oe,X=le,W=ce;const Z=v[0],Q=v[1];for(V=$(g,v[R-1],0,V),X=$(g,Q,0,X),q=$(g,Z,0,q),F=$(g,Z,y,F),W=h?ne(V,q,F,X,W):Y(Z,Q,y,g,W),t.Cartesian3.pack(W,j,0),t.Cartesian3.pack(q,B,0),t.Cartesian3.pack(F,G,0),H.push(Z.latitude),H.push(Z.longitude),U(Z,Q,0,y,f,m,g,j,B,G,H),T=1;T<R-1;++T){V=t.Cartesian3.clone(q,V),q=t.Cartesian3.clone(X,q);const e=v[T];$(g,e,y,F),$(g,v[T+1],0,X),ne(V,q,F,X,W),M=j.length,t.Cartesian3.pack(W,j,M),t.Cartesian3.pack(q,B,M),t.Cartesian3.pack(F,G,M),H.push(e.latitude),H.push(e.longitude),U(v[T],v[T+1],0,y,f,m,g,j,B,G,H)}const K=v[R-1],ee=v[R-2];if(q=$(g,K,0,q),F=$(g,K,y,F),h){const e=v[0];V=$(g,ee,0,V),X=$(g,e,0,X),W=ne(V,q,F,X,W)}else W=Y(ee,K,y,g,W);if(M=j.length,t.Cartesian3.pack(W,j,M),t.Cartesian3.pack(q,B,M),t.Cartesian3.pack(F,G,M),H.push(K.latitude),H.push(K.longitude),h){for(U(K,Z,0,y,f,m,g,j,B,G,H),M=j.length,T=0;T<3;++T)j[M+T]=j[T],B[M+T]=B[T],G[M+T]=G[T];H.push(Z.latitude),H.push(Z.longitude)}return function(a,n,s,o,c,u,d){let h,g;const f=n._ellipsoid,m=s.length/3-1,w=8*m,y=4*w,M=36*m,T=w>65535?new Uint32Array(M):new Uint16Array(M),E=new Float64Array(3*w),_=new Float32Array(y),O=new Float32Array(y),b=new Float32Array(y),P=new Float32Array(y),k=new Float32Array(y);let A,L,S,x;d&&(A=new Float32Array(y),L=new Float32Array(y),S=new Float32Array(y),x=new Float32Array(2*w));const I=u.length/2;let R=0;const D=Ae;D.height=0;const v=Le;v.height=0;let H=Se,j=xe;if(d)for(g=0,h=1;h<I;h++)D.latitude=u[g],D.longitude=u[g+1],v.latitude=u[g+2],v.longitude=u[g+3],H=n.project(D,H),j=n.project(v,j),R+=t.Cartesian3.distance(H,j),g+=2;const B=o.length/3;j=t.Cartesian3.unpack(o,0,j);let G,V=0;for(g=3,h=1;h<B;h++)H=t.Cartesian3.clone(j,H),j=t.Cartesian3.unpack(o,g,j),V+=t.Cartesian3.distance(H,j),g+=3;g=3;let Y=0,q=0,F=0,X=0,W=!1,U=t.Cartesian3.unpack(s,0,Ne),Z=t.Cartesian3.unpack(o,0,xe),$=t.Cartesian3.unpack(c,0,De);if(a){me($,t.Cartesian3.unpack(s,s.length-6,Ie),U,Z)&&($=t.Cartesian3.negate($,$))}let Q=0,K=0,ee=0;for(h=0;h<m;h++){const e=t.Cartesian3.clone(U,Ie),a=t.Cartesian3.clone(Z,Se);let l,p,h,m,w=t.Cartesian3.clone($,Re);if(W&&(w=t.Cartesian3.negate(w,w)),U=t.Cartesian3.unpack(s,g,Ne),Z=t.Cartesian3.unpack(o,g,xe),$=t.Cartesian3.unpack(c,g,De),W=me($,e,U,Z),D.latitude=u[Y],D.longitude=u[Y+1],v.latitude=u[Y+2],v.longitude=u[Y+3],d){const e=ke(D,v);l=n.project(D,Ve),p=n.project(v,Ye);const a=J(p,l,et);a.y=Math.abs(a.y),h=qe,m=Fe,0===e||t.Cartesian3.dot(a,t.Cartesian3.UNIT_Y)>z?(h=Te(n,D,w,l,qe),m=Te(n,v,$,p,Fe)):1===e?(m=Te(n,v,$,p,Fe),h.x=0,h.y=r.CesiumMath.sign(D.longitude-Math.abs(v.longitude)),h.z=0):(h=Te(n,D,w,l,qe),m.x=0,m.y=r.CesiumMath.sign(D.longitude-v.longitude),m.z=0)}const y=t.Cartesian3.distance(a,Z),M=C.EncodedCartesian3.fromCartesian(e,Qe),T=t.Cartesian3.subtract(U,e,Xe),I=t.Cartesian3.normalize(T,Ze);let H=t.Cartesian3.subtract(a,e,We);H=t.Cartesian3.normalize(H,H);let j=t.Cartesian3.cross(I,H,Ze);j=t.Cartesian3.normalize(j,j);let B=t.Cartesian3.cross(H,w,$e);B=t.Cartesian3.normalize(B,B);let te=t.Cartesian3.subtract(Z,U,Ue);te=t.Cartesian3.normalize(te,te);let ae=t.Cartesian3.cross($,te,Je);ae=t.Cartesian3.normalize(ae,ae);const ne=y/V,ie=Q/V;let re,se,oe,le=0,ce=0,ue=0;if(d){le=t.Cartesian3.distance(l,p),re=C.EncodedCartesian3.fromCartesian(l,Ke),se=t.Cartesian3.subtract(p,l,et),oe=t.Cartesian3.normalize(se,tt);const e=oe.x;oe.x=oe.y,oe.y=-e,ce=le/R,ue=K/R}for(G=0;G<8;G++){const e=X+4*G,a=q+2*G,n=e+3,i=G<4?1:-1,r=2===G||3===G||6===G||7===G?1:-1;t.Cartesian3.pack(M.high,_,e),_[n]=T.x,t.Cartesian3.pack(M.low,O,e),O[n]=T.y,t.Cartesian3.pack(B,b,e),b[n]=T.z,t.Cartesian3.pack(ae,P,e),P[n]=ne*i,t.Cartesian3.pack(j,k,e);let s=ie*r;0===s&&r<0&&(s=9),k[n]=s,d&&(A[e]=re.high.x,A[e+1]=re.high.y,A[e+2]=re.low.x,A[e+3]=re.low.y,S[e]=-h.y,S[e+1]=h.x,S[e+2]=m.y,S[e+3]=-m.x,L[e]=se.x,L[e+1]=se.y,L[e+2]=oe.x,L[e+3]=oe.y,x[a]=ce*i,s=ue*r,0===s&&r<0&&(s=9),x[a+1]=s)}const Ce=Be,pe=Ge,de=He,he=je,ge=i.Rectangle.fromCartographicArray(ve,ze),fe=N.getMinimumMaximumHeights(ge,f),we=fe.minimumTerrainHeight,ye=fe.maximumTerrainHeight;ee+=we,ee+=ye,Oe(e,a,we,ye,Ce,de),Oe(U,Z,we,ye,pe,he);let Me=t.Cartesian3.multiplyByScalar(j,r.CesiumMath.EPSILON5,at);t.Cartesian3.add(Ce,Me,Ce),t.Cartesian3.add(pe,Me,pe),t.Cartesian3.add(de,Me,de),t.Cartesian3.add(he,Me,he),Pe(Ce,pe),Pe(de,he),t.Cartesian3.pack(Ce,E,F),t.Cartesian3.pack(pe,E,F+3),t.Cartesian3.pack(he,E,F+6),t.Cartesian3.pack(de,E,F+9),Me=t.Cartesian3.multiplyByScalar(j,-2*r.CesiumMath.EPSILON5,at),t.Cartesian3.add(Ce,Me,Ce),t.Cartesian3.add(pe,Me,pe),t.Cartesian3.add(de,Me,de),t.Cartesian3.add(he,Me,he),Pe(Ce,pe),Pe(de,he),t.Cartesian3.pack(Ce,E,F+12),t.Cartesian3.pack(pe,E,F+15),t.Cartesian3.pack(he,E,F+18),t.Cartesian3.pack(de,E,F+21),Y+=2,g+=3,q+=16,F+=24,X+=32,Q+=y,K+=le}g=0;let te=0;for(h=0;h<m;h++){for(G=0;G<rt;G++)T[g+G]=it[G]+te;te+=8,g+=rt}const ae=nt;e.BoundingSphere.fromVertices(s,t.Cartesian3.ZERO,3,ae[0]),e.BoundingSphere.fromVertices(o,t.Cartesian3.ZERO,3,ae[1]);const ne=e.BoundingSphere.fromBoundingSpheres(ae);ne.radius+=ee/(2*m);const ie={position:new p.GeometryAttribute({componentDatatype:l.ComponentDatatype.DOUBLE,componentsPerAttribute:3,normalize:!1,values:E}),startHiAndForwardOffsetX:st(_),startLoAndForwardOffsetY:st(O),startNormalAndForwardOffsetZ:st(b),endNormalAndTextureCoordinateNormalizationX:st(P),rightNormalAndTextureCoordinateNormalizationY:st(k)};d&&(ie.startHiLo2D=st(A),ie.offsetAndRight2D=st(L),ie.startEndNormals2D=st(S),ie.texcoordNormalization2D=new p.GeometryAttribute({componentDatatype:l.ComponentDatatype.FLOAT,componentsPerAttribute:2,normalize:!1,values:x}));return new p.Geometry({attributes:ie,indices:T,boundingSphere:ne})}(h,w,B,G,j,H,c)};const he=new t.Cartesian3,ge=new t.Matrix3,fe=new e.Quaternion;function me(a,n,i,s){const o=J(i,n,he),l=t.Cartesian3.dot(o,a);if(l>z||l<H){const n=J(s,i,ae),o=l<H?r.CesiumMath.PI_OVER_TWO:-r.CesiumMath.PI_OVER_TWO,c=e.Quaternion.fromAxisAngle(n,o,fe),u=t.Matrix3.fromQuaternion(c,ge);return t.Matrix3.multiplyByVector(u,a,a),!0}return!1}const we=new t.Cartographic,ye=new t.Cartesian3,Me=new t.Cartesian3;function Te(e,a,n,i,s){const o=t.Cartographic.toCartesian(a,e._ellipsoid,ye);let l=t.Cartesian3.add(o,n,Me),c=!1;const u=e._ellipsoid;let C=u.cartesianToCartographic(l,we);Math.abs(a.longitude-C.longitude)>r.CesiumMath.PI_OVER_TWO&&(c=!0,l=t.Cartesian3.subtract(o,n,Me),C=u.cartesianToCartographic(l,we)),C.height=0;const p=e.project(C,s);return(s=t.Cartesian3.subtract(p,i,s)).z=0,s=t.Cartesian3.normalize(s,s),c&&t.Cartesian3.negate(s,s),s}const Ee=new t.Cartesian3,_e=new t.Cartesian3;function Oe(e,a,n,i,r,s){const o=t.Cartesian3.subtract(a,e,Ee);t.Cartesian3.normalize(o,o);const l=n-0;let c=t.Cartesian3.multiplyByScalar(o,l,_e);t.Cartesian3.add(e,c,r);const u=i-1e3;c=t.Cartesian3.multiplyByScalar(o,u,_e),t.Cartesian3.add(a,c,s)}const be=new t.Cartesian3;function Pe(e,a){const n=h.Plane.getPointDistance(ie,e),i=h.Plane.getPointDistance(ie,a);let s=be;r.CesiumMath.equalsEpsilon(n,0,r.CesiumMath.EPSILON2)?(s=J(a,e,s),t.Cartesian3.multiplyByScalar(s,r.CesiumMath.EPSILON2,s),t.Cartesian3.add(e,s,e)):r.CesiumMath.equalsEpsilon(i,0,r.CesiumMath.EPSILON2)&&(s=J(e,a,s),t.Cartesian3.multiplyByScalar(s,r.CesiumMath.EPSILON2,s),t.Cartesian3.add(a,s,a))}function ke(e,t){const a=Math.abs(e.longitude),n=Math.abs(t.longitude);if(r.CesiumMath.equalsEpsilon(a,r.CesiumMath.PI,r.CesiumMath.EPSILON11)){const n=r.CesiumMath.sign(t.longitude);return e.longitude=n*(a-r.CesiumMath.EPSILON11),1}if(r.CesiumMath.equalsEpsilon(n,r.CesiumMath.PI,r.CesiumMath.EPSILON11)){const a=r.CesiumMath.sign(e.longitude);return t.longitude=a*(n-r.CesiumMath.EPSILON11),2}return 0}const Ae=new t.Cartographic,Le=new t.Cartographic,Se=new t.Cartesian3,xe=new t.Cartesian3,Ie=new t.Cartesian3,Ne=new t.Cartesian3,Re=new t.Cartesian3,De=new t.Cartesian3,ve=[Ae,Le],ze=new i.Rectangle,He=new t.Cartesian3,je=new t.Cartesian3,Be=new t.Cartesian3,Ge=new t.Cartesian3,Ve=new t.Cartesian3,Ye=new t.Cartesian3,qe=new t.Cartesian3,Fe=new t.Cartesian3,Xe=new t.Cartesian3,We=new t.Cartesian3,Ue=new t.Cartesian3,Ze=new t.Cartesian3,$e=new t.Cartesian3,Je=new t.Cartesian3,Qe=new C.EncodedCartesian3,Ke=new C.EncodedCartesian3,et=new t.Cartesian3,tt=new t.Cartesian3,at=new t.Cartesian3,nt=[new e.BoundingSphere,new e.BoundingSphere],it=[0,2,1,0,3,2,0,7,3,0,4,7,0,5,4,0,1,5,5,7,4,5,6,7,5,2,6,5,1,2,3,6,2,3,7,6],rt=it.length;function st(e){return new p.GeometryAttribute({componentDatatype:l.ComponentDatatype.FLOAT,componentsPerAttribute:4,normalize:!1,values:e})}return j._projectNormal=Te,function(e,t){return N.initialize().then((function(){return n.defined(t)&&(e=j.unpack(e,t)),j.createGeometry(e)}))}}));
