/**
 * @license
 * Cesium - https://github.com/CesiumGS/cesium
 * Version 1.96
 *
 * Copyright 2011-2022 Cesium Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Columbus View (Pat. Pend.)
 *
 * Portions licensed separately.
 * See https://github.com/CesiumGS/cesium/blob/main/LICENSE.md for full licensing details.
 */
define(["./defined-b681f02d","./Rectangle-0610a1c7","./ArcType-f5af12f9","./Transforms-99c89742","./Matrix4-d3db9505","./Color-151cb095","./ComponentDatatype-46a1cf7a","./Check-436535f3","./GeometryAttribute-ef6ca9ab","./GeometryAttributes-18ccc0d6","./IndexDatatype-1b44a4e6","./Math-5b6faca9","./PolylinePipeline-c42c443b","./Interval-49d6e8fc","./_commonjsHelpers-a32ac251","./combine-8b9ba6cb","./RequestType-e53aab71","./RuntimeError-14317824","./WebGLConstants-f100e3dd","./Matrix2-7384588e","./EllipsoidGeodesic-bd79a412","./EllipsoidRhumbLine-65d4aeca","./IntersectionTests-3ac7f0c9","./Plane-172c23d7"],(function(e,o,t,l,r,n,a,i,s,c,p,d,f,y,u,h,C,T,g,m,b,_,P,B){"use strict";function A(e,o,t,l,r,a,i){const s=f.PolylinePipeline.numberOfPoints(e,o,r);let c;const p=t.red,d=t.green,y=t.blue,u=t.alpha,h=l.red,C=l.green,T=l.blue,g=l.alpha;if(n.Color.equals(t,l)){for(c=0;c<s;c++)a[i++]=n.Color.floatToByte(p),a[i++]=n.Color.floatToByte(d),a[i++]=n.Color.floatToByte(y),a[i++]=n.Color.floatToByte(u);return i}const m=(h-p)/s,b=(C-d)/s,_=(T-y)/s,P=(g-u)/s;let B=i;for(c=0;c<s;c++)a[B++]=n.Color.floatToByte(p+c*m),a[B++]=n.Color.floatToByte(d+c*b),a[B++]=n.Color.floatToByte(y+c*_),a[B++]=n.Color.floatToByte(u+c*P);return B}function E(l){const a=(l=e.defaultValue(l,e.defaultValue.EMPTY_OBJECT)).positions,i=l.colors,s=e.defaultValue(l.colorsPerVertex,!1);this._positions=a,this._colors=i,this._colorsPerVertex=s,this._arcType=e.defaultValue(l.arcType,t.ArcType.GEODESIC),this._granularity=e.defaultValue(l.granularity,d.CesiumMath.RADIANS_PER_DEGREE),this._ellipsoid=e.defaultValue(l.ellipsoid,o.Ellipsoid.WGS84),this._workerName="createSimplePolylineGeometry";let c=1+a.length*r.Cartesian3.packedLength;c+=e.defined(i)?1+i.length*n.Color.packedLength:1,this.packedLength=c+o.Ellipsoid.packedLength+3}E.pack=function(t,l,a){let i;a=e.defaultValue(a,0);const s=t._positions;let c=s.length;for(l[a++]=c,i=0;i<c;++i,a+=r.Cartesian3.packedLength)r.Cartesian3.pack(s[i],l,a);const p=t._colors;for(c=e.defined(p)?p.length:0,l[a++]=c,i=0;i<c;++i,a+=n.Color.packedLength)n.Color.pack(p[i],l,a);return o.Ellipsoid.pack(t._ellipsoid,l,a),a+=o.Ellipsoid.packedLength,l[a++]=t._colorsPerVertex?1:0,l[a++]=t._arcType,l[a]=t._granularity,l},E.unpack=function(t,l,a){let i;l=e.defaultValue(l,0);let s=t[l++];const c=new Array(s);for(i=0;i<s;++i,l+=r.Cartesian3.packedLength)c[i]=r.Cartesian3.unpack(t,l);s=t[l++];const p=s>0?new Array(s):void 0;for(i=0;i<s;++i,l+=n.Color.packedLength)p[i]=n.Color.unpack(t,l);const d=o.Ellipsoid.unpack(t,l);l+=o.Ellipsoid.packedLength;const f=1===t[l++],y=t[l++],u=t[l];return e.defined(a)?(a._positions=c,a._colors=p,a._ellipsoid=d,a._colorsPerVertex=f,a._arcType=y,a._granularity=u,a):new E({positions:c,colors:p,ellipsoid:d,colorsPerVertex:f,arcType:y,granularity:u})};const k=new Array(2),G=new Array(2),D={positions:k,height:G,ellipsoid:void 0,minDistance:void 0,granularity:void 0};return E.createGeometry=function(o){const i=o._positions,y=o._colors,u=o._colorsPerVertex,h=o._arcType,C=o._granularity,T=o._ellipsoid,g=d.CesiumMath.chordLength(C,T.maximumRadius),m=e.defined(y)&&!u;let b;const _=i.length;let P,B,E,L,w=0;if(h===t.ArcType.GEODESIC||h===t.ArcType.RHUMB){let o,l,r;h===t.ArcType.GEODESIC?(o=d.CesiumMath.chordLength(C,T.maximumRadius),l=f.PolylinePipeline.numberOfPoints,r=f.PolylinePipeline.generateArc):(o=C,l=f.PolylinePipeline.numberOfPointsRhumbLine,r=f.PolylinePipeline.generateRhumbArc);const a=f.PolylinePipeline.extractHeights(i,T),s=D;if(h===t.ArcType.GEODESIC?s.minDistance=g:s.granularity=C,s.ellipsoid=T,m){let t=0;for(b=0;b<_-1;b++)t+=l(i[b],i[b+1],o)+1;P=new Float64Array(3*t),E=new Uint8Array(4*t),s.positions=k,s.height=G;let c=0;for(b=0;b<_-1;++b){k[0]=i[b],k[1]=i[b+1],G[0]=a[b],G[1]=a[b+1];const o=r(s);if(e.defined(y)){const e=o.length/3;L=y[b];for(let o=0;o<e;++o)E[c++]=n.Color.floatToByte(L.red),E[c++]=n.Color.floatToByte(L.green),E[c++]=n.Color.floatToByte(L.blue),E[c++]=n.Color.floatToByte(L.alpha)}P.set(o,w),w+=o.length}}else if(s.positions=i,s.height=a,P=new Float64Array(r(s)),e.defined(y)){for(E=new Uint8Array(P.length/3*4),b=0;b<_-1;++b){w=A(i[b],i[b+1],y[b],y[b+1],g,E,w)}const e=y[_-1];E[w++]=n.Color.floatToByte(e.red),E[w++]=n.Color.floatToByte(e.green),E[w++]=n.Color.floatToByte(e.blue),E[w++]=n.Color.floatToByte(e.alpha)}}else{B=m?2*_-2:_,P=new Float64Array(3*B),E=e.defined(y)?new Uint8Array(4*B):void 0;let o=0,t=0;for(b=0;b<_;++b){const l=i[b];if(m&&b>0&&(r.Cartesian3.pack(l,P,o),o+=3,L=y[b-1],E[t++]=n.Color.floatToByte(L.red),E[t++]=n.Color.floatToByte(L.green),E[t++]=n.Color.floatToByte(L.blue),E[t++]=n.Color.floatToByte(L.alpha)),m&&b===_-1)break;r.Cartesian3.pack(l,P,o),o+=3,e.defined(y)&&(L=y[b],E[t++]=n.Color.floatToByte(L.red),E[t++]=n.Color.floatToByte(L.green),E[t++]=n.Color.floatToByte(L.blue),E[t++]=n.Color.floatToByte(L.alpha))}}const V=new c.GeometryAttributes;V.position=new s.GeometryAttribute({componentDatatype:a.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:P}),e.defined(y)&&(V.color=new s.GeometryAttribute({componentDatatype:a.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:4,values:E,normalize:!0})),B=P.length/3;const x=2*(B-1),R=p.IndexDatatype.createTypedArray(B,x);let I=0;for(b=0;b<B-1;++b)R[I++]=b,R[I++]=b+1;return new s.Geometry({attributes:V,indices:R,primitiveType:s.PrimitiveType.LINES,boundingSphere:l.BoundingSphere.fromPoints(i)})},function(t,l){return e.defined(l)&&(t=E.unpack(t,l)),t._ellipsoid=o.Ellipsoid.clone(t._ellipsoid),E.createGeometry(t)}}));
