/**
 * @license
 * Cesium - https://github.com/CesiumGS/cesium
 * Version 1.96
 *
 * Copyright 2011-2022 Cesium Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Columbus View (Pat. Pend.)
 *
 * Portions licensed separately.
 * See https://github.com/CesiumGS/cesium/blob/main/LICENSE.md for full licensing details.
 */
define(["exports","./Matrix4-d3db9505","./PolylineVolumeGeometryLibrary-9b126e47","./defined-b681f02d","./Rectangle-0610a1c7","./EllipsoidGeodesic-bd79a412","./Math-5b6faca9","./PolylinePipeline-c42c443b","./Transforms-99c89742"],(function(a,e,t,n,r,i,s,o,l){"use strict";var C=Object.freeze({NONE:0,CLAMP_TO_GROUND:1,RELATIVE_TO_GROUND:2});const c={},u=new e.Cartesian3,p=new e.Cartesian3,d=new e.Cartesian3,y=new e.Cartesian3,h=[new e.Cartesian3,new e.Cartesian3],m=new e.Cartesian3,g=new e.Cartesian3,f=new e.Cartesian3,w=new e.Cartesian3,z=new e.Cartesian3,b=new e.Cartesian3,E=new e.Cartesian3,S=new e.Cartesian3,B=new e.Cartesian3,x=new e.Cartesian3,P=new l.Quaternion,N=new e.Matrix3;function A(a,n,r,i,o){const C=e.Cartesian3.angleBetween(e.Cartesian3.subtract(n,a,u),e.Cartesian3.subtract(r,a,p)),c=i===t.CornerType.BEVELED?1:Math.ceil(C/s.CesiumMath.toRadians(5))+1,d=3*c,y=new Array(d);let h;y[d-3]=r.x,y[d-2]=r.y,y[d-1]=r.z,h=o?e.Matrix3.fromQuaternion(l.Quaternion.fromAxisAngle(e.Cartesian3.negate(a,u),C/c,P),N):e.Matrix3.fromQuaternion(l.Quaternion.fromAxisAngle(a,C/c,P),N);let m=0;n=e.Cartesian3.clone(n,u);for(let a=0;a<c;a++)n=e.Matrix3.multiplyByVector(h,n,n),y[m++]=n.x,y[m++]=n.y,y[m++]=n.z;return y}function T(a,t,n,r){let i=u;return r||(t=e.Cartesian3.negate(t,t)),i=e.Cartesian3.add(a,t,i),[i.x,i.y,i.z,n.x,n.y,n.z]}function M(a,t,n,r){const i=new Array(a.length),s=new Array(a.length),o=e.Cartesian3.multiplyByScalar(t,n,u),l=e.Cartesian3.negate(o,p);let C=0,c=a.length-1;for(let t=0;t<a.length;t+=3){const n=e.Cartesian3.fromArray(a,t,d),r=e.Cartesian3.add(n,l,y);i[C++]=r.x,i[C++]=r.y,i[C++]=r.z;const u=e.Cartesian3.add(n,o,y);s[c--]=u.z,s[c--]=u.y,s[c--]=u.x}return r.push(i,s),r}function D(a,t){const n=a[0],r=a[1],i=a[2],s=new e.Cartesian3,o=new e.Cartesian3,l=new e.Cartesian3,C=1/(t+1);let c=0;const u=new Array(t);for(let a=0;a<t;a++){c=(a+1)*C;const t=(1-c)*(1-c),p=2*c*(1-c),d=c*c;e.Cartesian3.multiplyByScalar(n,t,s),e.Cartesian3.multiplyByScalar(r,p,o),e.Cartesian3.multiplyByScalar(i,d,l),e.Cartesian3.add(s,o,o),u[a]=e.Cartesian3.add(o,l,new e.Cartesian3)}return u}c.addAttribute=function(a,e,t,r){const i=e.x,s=e.y,o=e.z;n.defined(t)&&(a[t]=i,a[t+1]=s,a[t+2]=o),n.defined(r)&&(a[r]=o,a[r-1]=s,a[r-2]=i)};const O=new e.Cartesian3,R=new e.Cartesian3;c.computePositions=function(a){const n=a.granularity,r=a.positions,i=a.ellipsoid,l=a.width/2,C=a.cornerType,c=a.saveAttributes;let p=m,d=g,y=f,P=w,N=z,D=b,L=E,G=S,U=B,V=x,_=[];const I=c?[]:void 0,v=c?[]:void 0;let Q,q=r[0],H=r[1];d=e.Cartesian3.normalize(e.Cartesian3.subtract(H,q,d),d),p=i.geodeticSurfaceNormal(q,p),P=e.Cartesian3.normalize(e.Cartesian3.cross(p,d,P),P),c&&(I.push(P.x,P.y,P.z),v.push(p.x,p.y,p.z)),L=e.Cartesian3.clone(q,L),q=H,y=e.Cartesian3.negate(d,y);const j=[];let W;const k=r.length;for(W=1;W<k-1;W++){p=i.geodeticSurfaceNormal(q,p),H=r[W+1],d=e.Cartesian3.normalize(e.Cartesian3.subtract(H,q,d),d),N=e.Cartesian3.normalize(e.Cartesian3.add(d,y,N),N);const a=e.Cartesian3.multiplyByScalar(p,e.Cartesian3.dot(d,p),O);e.Cartesian3.subtract(d,a,a),e.Cartesian3.normalize(a,a);const m=e.Cartesian3.multiplyByScalar(p,e.Cartesian3.dot(y,p),R);e.Cartesian3.subtract(y,m,m),e.Cartesian3.normalize(m,m);if(!s.CesiumMath.equalsEpsilon(Math.abs(e.Cartesian3.dot(a,m)),1,s.CesiumMath.EPSILON7)){N=e.Cartesian3.cross(N,p,N),N=e.Cartesian3.cross(p,N,N),N=e.Cartesian3.normalize(N,N);const a=l/Math.max(.25,e.Cartesian3.magnitude(e.Cartesian3.cross(N,y,u))),r=t.PolylineVolumeGeometryLibrary.angleIsGreaterThanPi(d,y,q,i);N=e.Cartesian3.multiplyByScalar(N,a,N),r?(G=e.Cartesian3.add(q,N,G),V=e.Cartesian3.add(G,e.Cartesian3.multiplyByScalar(P,l,V),V),U=e.Cartesian3.add(G,e.Cartesian3.multiplyByScalar(P,2*l,U),U),h[0]=e.Cartesian3.clone(L,h[0]),h[1]=e.Cartesian3.clone(V,h[1]),Q=o.PolylinePipeline.generateArc({positions:h,granularity:n,ellipsoid:i}),_=M(Q,P,l,_),c&&(I.push(P.x,P.y,P.z),v.push(p.x,p.y,p.z)),D=e.Cartesian3.clone(U,D),P=e.Cartesian3.normalize(e.Cartesian3.cross(p,d,P),P),U=e.Cartesian3.add(G,e.Cartesian3.multiplyByScalar(P,2*l,U),U),L=e.Cartesian3.add(G,e.Cartesian3.multiplyByScalar(P,l,L),L),C===t.CornerType.ROUNDED||C===t.CornerType.BEVELED?j.push({leftPositions:A(G,D,U,C,r)}):j.push({leftPositions:T(q,e.Cartesian3.negate(N,N),U,r)})):(U=e.Cartesian3.add(q,N,U),V=e.Cartesian3.add(U,e.Cartesian3.negate(e.Cartesian3.multiplyByScalar(P,l,V),V),V),G=e.Cartesian3.add(U,e.Cartesian3.negate(e.Cartesian3.multiplyByScalar(P,2*l,G),G),G),h[0]=e.Cartesian3.clone(L,h[0]),h[1]=e.Cartesian3.clone(V,h[1]),Q=o.PolylinePipeline.generateArc({positions:h,granularity:n,ellipsoid:i}),_=M(Q,P,l,_),c&&(I.push(P.x,P.y,P.z),v.push(p.x,p.y,p.z)),D=e.Cartesian3.clone(G,D),P=e.Cartesian3.normalize(e.Cartesian3.cross(p,d,P),P),G=e.Cartesian3.add(U,e.Cartesian3.negate(e.Cartesian3.multiplyByScalar(P,2*l,G),G),G),L=e.Cartesian3.add(U,e.Cartesian3.negate(e.Cartesian3.multiplyByScalar(P,l,L),L),L),C===t.CornerType.ROUNDED||C===t.CornerType.BEVELED?j.push({rightPositions:A(U,D,G,C,r)}):j.push({rightPositions:T(q,N,G,r)})),y=e.Cartesian3.negate(d,y)}q=H}let F;return p=i.geodeticSurfaceNormal(q,p),h[0]=e.Cartesian3.clone(L,h[0]),h[1]=e.Cartesian3.clone(q,h[1]),Q=o.PolylinePipeline.generateArc({positions:h,granularity:n,ellipsoid:i}),_=M(Q,P,l,_),c&&(I.push(P.x,P.y,P.z),v.push(p.x,p.y,p.z)),C===t.CornerType.ROUNDED&&(F=function(a){let n=m,r=g,i=f,s=a[1];r=e.Cartesian3.fromArray(a[1],s.length-3,r),i=e.Cartesian3.fromArray(a[0],0,i),n=e.Cartesian3.midpoint(r,i,n);const o=A(n,r,i,t.CornerType.ROUNDED,!1),l=a.length-1,C=a[l-1];return s=a[l],r=e.Cartesian3.fromArray(C,C.length-3,r),i=e.Cartesian3.fromArray(s,0,i),n=e.Cartesian3.midpoint(r,i,n),[o,A(n,r,i,t.CornerType.ROUNDED,!1)]}(_)),{positions:_,corners:j,lefts:I,normals:v,endPositions:F}},c.computeInterpolationPositions=function(a){const t=a.positions,r=a.width/2,o=a.globe,l=o.ellipsoid,c=a.granularity,u=a.cornerLength,p=a.height,d=n.defaultValue(a.heightReference,C.NONE),y=Math.PI;if(t.length<2)return;let h=m,E=g,S=f;const B=w;let x=z,P=b;const N=new e.Cartographic,A=s.CesiumMath.toRadians(170),T=new i.EllipsoidGeodesic(null,null,l);let M=t[0],L=t[1],G=null;const U=[I(t[0])];h=e.Cartesian3.normalize(e.Cartesian3.subtract(L,M,h),h),E=e.Cartesian3.negate(h,E);const V=t.length-1;for(let a=1;a<V;a++){G=t[a+1],h=e.Cartesian3.normalize(e.Cartesian3.subtract(G,L,h),h),S=l.geodeticSurfaceNormal(L,S);const n=e.Cartesian3.multiplyByScalar(S,e.Cartesian3.dot(h,S),O);e.Cartesian3.subtract(h,n,n),e.Cartesian3.normalize(n,n);const i=e.Cartesian3.multiplyByScalar(S,e.Cartesian3.dot(E,S),R);e.Cartesian3.subtract(E,i,i),e.Cartesian3.normalize(i,i);const s=Math.acos(e.Cartesian3.dot(n,i));if(s<A){let a=(u/(y-s)+r)*Math.tan((y-s)/2);if(a<=0)continue;const t=e.Cartesian3.distance(L,G),n=e.Cartesian3.distance(L,M);a=Math.min(a,t,n),x=e.Cartesian3.add(L,e.Cartesian3.multiplyByScalar(E,a,x),x),P=e.Cartesian3.add(L,e.Cartesian3.multiplyByScalar(h,a,P),P),_(M,x);const i=Math.ceil(u/r*10),o=D([x,L,P],i);for(let a=0;a<i;a++)U.push(I(o[a],o[a]));U.push(I(P)),M=e.Cartesian3.clone(P,B)}else _(M,L),M=L;L=G,E=e.Cartesian3.negate(h,E)}_(M,L);for(let a=1;a<U.length;++a)e.Cartesian3.equals(U[a-1],U[a])&&(U.splice(a,1),--a);return U;function _(a,e){const t=l.cartesianToCartographic(a),n=l.cartesianToCartographic(e),r=n.height-t.height;T.setEndPoints(t,n);let i=c;const s=T.surfaceDistance;if(!(s<=0)){for(;i<s;)T.interpolateUsingSurfaceDistance(i,N),N.height=t.height+i/s*r,v(N),U.push(l.cartographicToCartesian(N)),i+=c;U.push(I(e))}}function I(a,t){return n.defined(p)||d!==C.NONE?(l.cartesianToCartographic(a,N),v(N),l.cartographicToCartesian(N,t)):t||e.Cartesian3.clone(a)}function v(a){if(d===C.CLAMP_TO_GROUND){const e=o.getHeight(a);e&&(a.height=e)}else if("number"==typeof p)if(d===C.NONE)a.height=p;else if(d===C.RELATIVE_TO_GROUND){const e=o.getHeight(a);e?a.height=e+p:console.error("获取地形高程失败！")}}},c.ev_computePositions=function(a){const t=a.positions,i=a.width/2,s=n.defaultValue(a.ellipsoid,r.Ellipsoid.WGS84);let o=m,l=g,C=f;const c=[],u=[],p=[],d=[];let y=t[0],h=null;for(let a=1,n=t.length;a<n;a++)h=t[a],o=s.geodeticSurfaceNormal(y,o),l=e.Cartesian3.subtract(h,y,l),C=e.Cartesian3.normalize(e.Cartesian3.cross(o,l,C),C),C=e.Cartesian3.multiplyByScalar(C,i,C),c.push(e.Cartesian3.add(y,C,new e.Cartesian3)),u.push(e.Cartesian3.subtract(y,C,new e.Cartesian3)),p.push(o),d.push(o),y=h;for(c.push(e.Cartesian3.add(y,C,new e.Cartesian3)),u.push(e.Cartesian3.subtract(y,C,new e.Cartesian3)),p.push(o),d.push(o);c.length>0;)u.push(c.pop()),d.push(p.pop());return{positions:u,normals:d}},a.CorridorGeometryLibrary=c}));
