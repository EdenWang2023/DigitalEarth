/**
 * @license
 * Cesium - https://github.com/CesiumGS/cesium
 * Version 1.96
 *
 * Copyright 2011-2022 Cesium Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Columbus View (Pat. Pend.)
 *
 * Portions licensed separately.
 * See https://github.com/CesiumGS/cesium/blob/main/LICENSE.md for full licensing details.
 */
define(["exports","./Matrix4-d3db9505","./Check-436535f3","./defined-b681f02d"],(function(n,t,e,r){"use strict";function u(n,t,e,u){this[0]=r.defaultValue(n,0),this[1]=r.defaultValue(e,0),this[2]=r.defaultValue(t,0),this[3]=r.defaultValue(u,0)}u.packedLength=4,u.pack=function(n,t,e){return e=r.defaultValue(e,0),t[e++]=n[0],t[e++]=n[1],t[e++]=n[2],t[e++]=n[3],t},u.unpack=function(n,t,e){return t=r.defaultValue(t,0),r.defined(e)||(e=new u),e[0]=n[t++],e[1]=n[t++],e[2]=n[t++],e[3]=n[t++],e},u.packArray=function(n,t){const e=n.length,o=4*e;r.defined(t)?(Array.isArray(t)||t.length===o)&&t.length!==o&&(t.length=o):t=new Array(o);for(let r=0;r<e;++r)u.pack(n[r],t,4*r);return t},u.unpackArray=function(n,t){const e=n.length;r.defined(t)?t.length=e/4:t=new Array(e/4);for(let r=0;r<e;r+=4){const e=r/4;t[e]=u.unpack(n,r,t[e])}return t},u.clone=function(n,t){if(r.defined(n))return r.defined(t)?(t[0]=n[0],t[1]=n[1],t[2]=n[2],t[3]=n[3],t):new u(n[0],n[2],n[1],n[3])},u.fromArray=u.unpack,u.fromColumnMajorArray=function(n,t){return u.clone(n,t)},u.fromRowMajorArray=function(n,t){return r.defined(t)?(t[0]=n[0],t[1]=n[2],t[2]=n[1],t[3]=n[3],t):new u(n[0],n[1],n[2],n[3])},u.fromScale=function(n,t){return r.defined(t)?(t[0]=n.x,t[1]=0,t[2]=0,t[3]=n.y,t):new u(n.x,0,0,n.y)},u.fromUniformScale=function(n,t){return r.defined(t)?(t[0]=n,t[1]=0,t[2]=0,t[3]=n,t):new u(n,0,0,n)},u.fromRotation=function(n,t){const e=Math.cos(n),o=Math.sin(n);return r.defined(t)?(t[0]=e,t[1]=o,t[2]=-o,t[3]=e,t):new u(e,-o,o,e)},u.toArray=function(n,t){return r.defined(t)?(t[0]=n[0],t[1]=n[1],t[2]=n[2],t[3]=n[3],t):[n[0],n[1],n[2],n[3]]},u.getElementIndex=function(n,t){return 2*n+t},u.getColumn=function(n,t,e){const r=2*t,u=n[r],o=n[r+1];return e.x=u,e.y=o,e},u.setColumn=function(n,t,e,r){const o=2*t;return(r=u.clone(n,r))[o]=e.x,r[o+1]=e.y,r},u.getRow=function(n,t,e){const r=n[t],u=n[t+2];return e.x=r,e.y=u,e},u.setRow=function(n,t,e,r){return(r=u.clone(n,r))[t]=e.x,r[t+2]=e.y,r};const o=new t.Cartesian2;u.setScale=function(n,t,e){const r=u.getScale(n,o),a=t.x/r.x,i=t.y/r.y;return e[0]=n[0]*a,e[1]=n[1]*a,e[2]=n[2]*i,e[3]=n[3]*i,e};const a=new t.Cartesian2;u.setUniformScale=function(n,t,e){const r=u.getScale(n,a),o=t/r.x,i=t/r.y;return e[0]=n[0]*o,e[1]=n[1]*o,e[2]=n[2]*i,e[3]=n[3]*i,e};const i=new t.Cartesian2;u.getScale=function(n,e){return e.x=t.Cartesian2.magnitude(t.Cartesian2.fromElements(n[0],n[1],i)),e.y=t.Cartesian2.magnitude(t.Cartesian2.fromElements(n[2],n[3],i)),e};const c=new t.Cartesian2;u.getMaximumScale=function(n){return u.getScale(n,c),t.Cartesian2.maximumComponent(c)};const f=new t.Cartesian2;u.setRotation=function(n,t,e){const r=u.getScale(n,f);return e[0]=t[0]*r.x,e[1]=t[1]*r.x,e[2]=t[2]*r.y,e[3]=t[3]*r.y,e};const s=new t.Cartesian2;u.getRotation=function(n,t){const e=u.getScale(n,s);return t[0]=n[0]/e.x,t[1]=n[1]/e.x,t[2]=n[2]/e.y,t[3]=n[3]/e.y,t},u.multiply=function(n,t,e){const r=n[0]*t[0]+n[2]*t[1],u=n[0]*t[2]+n[2]*t[3],o=n[1]*t[0]+n[3]*t[1],a=n[1]*t[2]+n[3]*t[3];return e[0]=r,e[1]=o,e[2]=u,e[3]=a,e},u.add=function(n,t,e){return e[0]=n[0]+t[0],e[1]=n[1]+t[1],e[2]=n[2]+t[2],e[3]=n[3]+t[3],e},u.subtract=function(n,t,e){return e[0]=n[0]-t[0],e[1]=n[1]-t[1],e[2]=n[2]-t[2],e[3]=n[3]-t[3],e},u.multiplyByVector=function(n,t,e){const r=n[0]*t.x+n[2]*t.y,u=n[1]*t.x+n[3]*t.y;return e.x=r,e.y=u,e},u.multiplyByScalar=function(n,t,e){return e[0]=n[0]*t,e[1]=n[1]*t,e[2]=n[2]*t,e[3]=n[3]*t,e},u.multiplyByScale=function(n,t,e){return e[0]=n[0]*t.x,e[1]=n[1]*t.x,e[2]=n[2]*t.y,e[3]=n[3]*t.y,e},u.multiplyByUniformScale=function(n,t,e){return e[0]=n[0]*t,e[1]=n[1]*t,e[2]=n[2]*t,e[3]=n[3]*t,e},u.negate=function(n,t){return t[0]=-n[0],t[1]=-n[1],t[2]=-n[2],t[3]=-n[3],t},u.transpose=function(n,t){const e=n[0],r=n[2],u=n[1],o=n[3];return t[0]=e,t[1]=r,t[2]=u,t[3]=o,t},u.abs=function(n,t){return t[0]=Math.abs(n[0]),t[1]=Math.abs(n[1]),t[2]=Math.abs(n[2]),t[3]=Math.abs(n[3]),t},u.equals=function(n,t){return n===t||r.defined(n)&&r.defined(t)&&n[0]===t[0]&&n[1]===t[1]&&n[2]===t[2]&&n[3]===t[3]},u.equalsArray=function(n,t,e){return n[0]===t[e]&&n[1]===t[e+1]&&n[2]===t[e+2]&&n[3]===t[e+3]},u.equalsEpsilon=function(n,t,e){return e=r.defaultValue(e,0),n===t||r.defined(n)&&r.defined(t)&&Math.abs(n[0]-t[0])<=e&&Math.abs(n[1]-t[1])<=e&&Math.abs(n[2]-t[2])<=e&&Math.abs(n[3]-t[3])<=e},u.IDENTITY=Object.freeze(new u(1,0,0,1)),u.ZERO=Object.freeze(new u(0,0,0,0)),u.COLUMN0ROW0=0,u.COLUMN0ROW1=1,u.COLUMN1ROW0=2,u.COLUMN1ROW1=3,Object.defineProperties(u.prototype,{length:{get:function(){return u.packedLength}}}),u.prototype.clone=function(n){return u.clone(this,n)},u.prototype.equals=function(n){return u.equals(this,n)},u.prototype.equalsEpsilon=function(n,t){return u.equalsEpsilon(this,n,t)},u.prototype.toString=function(){return`(${this[0]}, ${this[2]})\n(${this[1]}, ${this[3]})`},n.Matrix2=u}));
