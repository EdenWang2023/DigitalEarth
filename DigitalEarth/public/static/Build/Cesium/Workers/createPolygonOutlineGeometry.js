/**
 * @license
 * Cesium - https://github.com/CesiumGS/cesium
 * Version 1.96
 *
 * Copyright 2011-2022 Cesium Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Columbus View (Pat. Pend.)
 *
 * Portions licensed separately.
 * See https://github.com/CesiumGS/cesium/blob/main/LICENSE.md for full licensing details.
 */
define(["./defined-b681f02d","./Rectangle-0610a1c7","./ArcType-f5af12f9","./Transforms-99c89742","./Matrix4-d3db9505","./Check-436535f3","./ComponentDatatype-46a1cf7a","./EllipsoidTangentPlane-34e5c0ac","./GeometryAttribute-ef6ca9ab","./GeometryAttributes-18ccc0d6","./GeometryInstance-458833d1","./GeometryOffsetAttribute-3e5f3e97","./GeometryPipeline-7151dba5","./IndexDatatype-1b44a4e6","./Math-5b6faca9","./PolygonGeometryLibrary-681888dc","./PolygonPipeline-5a6c6b44","./Interval-49d6e8fc","./_commonjsHelpers-a32ac251","./combine-8b9ba6cb","./RequestType-e53aab71","./RuntimeError-14317824","./WebGLConstants-f100e3dd","./AxisAlignedBoundingBox-321a482b","./IntersectionTests-3ac7f0c9","./Plane-172c23d7","./Matrix2-7384588e","./AttributeCompression-055d015a","./EncodedCartesian3-e8f321af","./arrayRemoveDuplicates-bbac3e0e","./EllipsoidRhumbLine-65d4aeca"],(function(e,t,i,o,r,n,a,s,l,y,u,p,c,d,f,g,m,h,b,P,E,A,_,G,L,T,H,v,C,x,O){"use strict";const D=[],I=[];function w(e,t,o,r,n){const p=s.EllipsoidTangentPlane.fromPoints(t,e).projectPointsOntoPlane(t,D);let c,f;m.PolygonPipeline.computeWindingOrder2D(p)===m.WindingOrder.CLOCKWISE&&(p.reverse(),t=t.slice().reverse());let h=t.length,b=0;if(r)for(c=new Float64Array(2*h*3),f=0;f<h;f++){const e=t[f],i=t[(f+1)%h];c[b++]=e.x,c[b++]=e.y,c[b++]=e.z,c[b++]=i.x,c[b++]=i.y,c[b++]=i.z}else{let r=0;if(n===i.ArcType.GEODESIC)for(f=0;f<h;f++)r+=g.PolygonGeometryLibrary.subdivideLineCount(t[f],t[(f+1)%h],o);else if(n===i.ArcType.RHUMB)for(f=0;f<h;f++)r+=g.PolygonGeometryLibrary.subdivideRhumbLineCount(e,t[f],t[(f+1)%h],o);for(c=new Float64Array(3*r),f=0;f<h;f++){let r;n===i.ArcType.GEODESIC?r=g.PolygonGeometryLibrary.subdivideLine(t[f],t[(f+1)%h],o,I):n===i.ArcType.RHUMB&&(r=g.PolygonGeometryLibrary.subdivideRhumbLine(e,t[f],t[(f+1)%h],o,I));const a=r.length;for(let e=0;e<a;++e)c[b++]=r[e]}}h=c.length/3;const P=2*h,E=d.IndexDatatype.createTypedArray(h,P);for(b=0,f=0;f<h-1;f++)E[b++]=f,E[b++]=f+1;return E[b++]=h-1,E[b++]=0,new u.GeometryInstance({geometry:new l.Geometry({attributes:new y.GeometryAttributes({position:new l.GeometryAttribute({componentDatatype:a.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:c})}),indices:E,primitiveType:l.PrimitiveType.LINES})})}function R(e,t,o,r,n){const p=s.EllipsoidTangentPlane.fromPoints(t,e).projectPointsOntoPlane(t,D);let c,f;m.PolygonPipeline.computeWindingOrder2D(p)===m.WindingOrder.CLOCKWISE&&(p.reverse(),t=t.slice().reverse());let h=t.length;const b=new Array(h);let P=0;if(r)for(c=new Float64Array(2*h*3*2),f=0;f<h;++f){b[f]=P/3;const e=t[f],i=t[(f+1)%h];c[P++]=e.x,c[P++]=e.y,c[P++]=e.z,c[P++]=i.x,c[P++]=i.y,c[P++]=i.z}else{let r=0;if(n===i.ArcType.GEODESIC)for(f=0;f<h;f++)r+=g.PolygonGeometryLibrary.subdivideLineCount(t[f],t[(f+1)%h],o);else if(n===i.ArcType.RHUMB)for(f=0;f<h;f++)r+=g.PolygonGeometryLibrary.subdivideRhumbLineCount(e,t[f],t[(f+1)%h],o);for(c=new Float64Array(3*r*2),f=0;f<h;++f){let r;b[f]=P/3,n===i.ArcType.GEODESIC?r=g.PolygonGeometryLibrary.subdivideLine(t[f],t[(f+1)%h],o,I):n===i.ArcType.RHUMB&&(r=g.PolygonGeometryLibrary.subdivideRhumbLine(e,t[f],t[(f+1)%h],o,I));const a=r.length;for(let e=0;e<a;++e)c[P++]=r[e]}}h=c.length/6;const E=b.length,A=2*(2*h+E),_=d.IndexDatatype.createTypedArray(h+E,A);for(P=0,f=0;f<h;++f)_[P++]=f,_[P++]=(f+1)%h,_[P++]=f+h,_[P++]=(f+1)%h+h;for(f=0;f<E;f++){const e=b[f];_[P++]=e,_[P++]=e+h}return new u.GeometryInstance({geometry:new l.Geometry({attributes:new y.GeometryAttributes({position:new l.GeometryAttribute({componentDatatype:a.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:c})}),indices:_,primitiveType:l.PrimitiveType.LINES})})}function S(o){const n=o.polygonHierarchy,a=e.defaultValue(o.ellipsoid,t.Ellipsoid.WGS84),s=e.defaultValue(o.granularity,f.CesiumMath.RADIANS_PER_DEGREE),l=e.defaultValue(o.perPositionHeight,!1),y=l&&e.defined(o.extrudedHeight),u=e.defaultValue(o.arcType,i.ArcType.GEODESIC);let p=e.defaultValue(o.height,0),c=e.defaultValue(o.extrudedHeight,p);if(!y){const e=Math.max(p,c);c=Math.min(p,c),p=e}this._ellipsoid=t.Ellipsoid.clone(a),this._granularity=s,this._height=p,this._extrudedHeight=c,this._arcType=u,this._polygonHierarchy=n,this._perPositionHeight=l,this._perPositionHeightExtrude=y,this._offsetAttribute=o.offsetAttribute,this._workerName="createPolygonOutlineGeometry",this.packedLength=g.PolygonGeometryLibrary.computeHierarchyPackedLength(n,r.Cartesian3)+t.Ellipsoid.packedLength+8}S.pack=function(i,o,n){return n=e.defaultValue(n,0),n=g.PolygonGeometryLibrary.packPolygonHierarchy(i._polygonHierarchy,o,n,r.Cartesian3),t.Ellipsoid.pack(i._ellipsoid,o,n),n+=t.Ellipsoid.packedLength,o[n++]=i._height,o[n++]=i._extrudedHeight,o[n++]=i._granularity,o[n++]=i._perPositionHeightExtrude?1:0,o[n++]=i._perPositionHeight?1:0,o[n++]=i._arcType,o[n++]=e.defaultValue(i._offsetAttribute,-1),o[n]=i.packedLength,o};const k=t.Ellipsoid.clone(t.Ellipsoid.UNIT_SPHERE),M={polygonHierarchy:{}};return S.unpack=function(i,o,n){o=e.defaultValue(o,0);const a=g.PolygonGeometryLibrary.unpackPolygonHierarchy(i,o,r.Cartesian3);o=a.startingIndex,delete a.startingIndex;const s=t.Ellipsoid.unpack(i,o,k);o+=t.Ellipsoid.packedLength;const l=i[o++],y=i[o++],u=i[o++],p=1===i[o++],c=1===i[o++],d=i[o++],f=i[o++],m=i[o];return e.defined(n)||(n=new S(M)),n._polygonHierarchy=a,n._ellipsoid=t.Ellipsoid.clone(s,n._ellipsoid),n._height=l,n._extrudedHeight=y,n._granularity=u,n._perPositionHeight=c,n._perPositionHeightExtrude=p,n._arcType=d,n._offsetAttribute=-1===f?void 0:f,n.packedLength=m,n},S.fromPositions=function(t){return new S({polygonHierarchy:{positions:(t=e.defaultValue(t,e.defaultValue.EMPTY_OBJECT)).positions},height:t.height,extrudedHeight:t.extrudedHeight,ellipsoid:t.ellipsoid,granularity:t.granularity,perPositionHeight:t.perPositionHeight,arcType:t.arcType,offsetAttribute:t.offsetAttribute})},S.createGeometry=function(t){const i=t._ellipsoid,r=t._granularity,n=t._polygonHierarchy,s=t._perPositionHeight,y=t._arcType,u=g.PolygonGeometryLibrary.polygonOutlinesFromHierarchy(n,!s,i);if(0===u.length)return;let d;const h=[],b=f.CesiumMath.chordLength(r,i.maximumRadius),P=t._height,E=t._extrudedHeight;let A,_;if(t._perPositionHeightExtrude||!f.CesiumMath.equalsEpsilon(P,E,0,f.CesiumMath.EPSILON2))for(_=0;_<u.length;_++){if(d=R(i,u[_],b,s,y),d.geometry=g.PolygonGeometryLibrary.scaleToGeodeticHeightExtruded(d.geometry,P,E,i,s),e.defined(t._offsetAttribute)){const e=d.geometry.attributes.position.values.length/3;let i=new Uint8Array(e);t._offsetAttribute===p.GeometryOffsetAttribute.TOP?i=i.fill(1,0,e/2):(A=t._offsetAttribute===p.GeometryOffsetAttribute.NONE?0:1,i=i.fill(A)),d.geometry.attributes.applyOffset=new l.GeometryAttribute({componentDatatype:a.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:i})}h.push(d)}else for(_=0;_<u.length;_++){if(d=w(i,u[_],b,s,y),d.geometry.attributes.position.values=m.PolygonPipeline.scaleToGeodeticHeight(d.geometry.attributes.position.values,P,i,!s),e.defined(t._offsetAttribute)){const e=d.geometry.attributes.position.values.length;A=t._offsetAttribute===p.GeometryOffsetAttribute.NONE?0:1;const i=new Uint8Array(e/3).fill(A);d.geometry.attributes.applyOffset=new l.GeometryAttribute({componentDatatype:a.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:i})}h.push(d)}const G=c.GeometryPipeline.combineInstances(h)[0],L=o.BoundingSphere.fromVertices(G.attributes.position.values);return new l.Geometry({attributes:G.attributes,indices:G.indices,primitiveType:G.primitiveType,boundingSphere:L,offsetAttribute:t._offsetAttribute})},function(i,o){return e.defined(o)&&(i=S.unpack(i,o)),i._ellipsoid=t.Ellipsoid.clone(i._ellipsoid),S.createGeometry(i)}}));
