/**
 * @license
 * Cesium - https://github.com/CesiumGS/cesium
 * Version 1.96
 *
 * Copyright 2011-2022 Cesium Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Columbus View (Pat. Pend.)
 *
 * Portions licensed separately.
 * See https://github.com/CesiumGS/cesium/blob/main/LICENSE.md for full licensing details.
 */
define(["./defined-b681f02d","./Rectangle-0610a1c7","./Transforms-99c89742","./Matrix4-d3db9505","./Check-436535f3","./ComponentDatatype-46a1cf7a","./GeometryAttribute-ef6ca9ab","./GeometryAttributes-18ccc0d6","./GeometryInstance-458833d1","./GeometryOffsetAttribute-3e5f3e97","./GeometryPipeline-7151dba5","./IndexDatatype-1b44a4e6","./Math-5b6faca9","./Matrix2-7384588e","./PolygonPipeline-5a6c6b44","./RectangleGeometryLibrary-516291fd","./VertexFormat-1359575c","./Interval-49d6e8fc","./_commonjsHelpers-a32ac251","./combine-8b9ba6cb","./RequestType-e53aab71","./RuntimeError-14317824","./WebGLConstants-f100e3dd","./AttributeCompression-055d015a","./EncodedCartesian3-e8f321af","./IntersectionTests-3ac7f0c9","./Plane-172c23d7","./EllipsoidRhumbLine-65d4aeca"],(function(t,e,n,a,o,r,i,s,l,u,c,m,d,p,g,y,f,h,b,_,A,x,w,C,v,R,E,G){"use strict";const F=new a.Cartesian3,P=new a.Cartesian3,V=new a.Cartesian3,L=new a.Cartesian3,D=new e.Rectangle,M=new a.Cartesian2,T=new n.BoundingSphere,O=new n.BoundingSphere;function N(t,e){const n=new i.Geometry({attributes:new s.GeometryAttributes,primitiveType:i.PrimitiveType.TRIANGLES});return n.attributes.position=new i.GeometryAttribute({componentDatatype:r.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:e.positions}),t.normal&&(n.attributes.normal=new i.GeometryAttribute({componentDatatype:r.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:e.normals})),t.tangent&&(n.attributes.tangent=new i.GeometryAttribute({componentDatatype:r.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:e.tangents})),t.bitangent&&(n.attributes.bitangent=new i.GeometryAttribute({componentDatatype:r.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:e.bitangents})),n}const S=new a.Cartesian3,I=new a.Cartesian3;function k(t,e){const n=t._vertexFormat,o=t._ellipsoid,s=e.height,l=e.width,u=e.northCap,c=e.southCap;let d=0,p=s,g=s,f=0;u&&(d=1,g-=1,f+=1),c&&(p-=1,g-=1,f+=1),f+=l*g;const h=n.position?new Float64Array(3*f):void 0,b=n.st?new Float32Array(2*f):void 0;let _=0,A=0;const x=F,w=M;let C=Number.MAX_VALUE,v=Number.MAX_VALUE,R=-Number.MAX_VALUE,E=-Number.MAX_VALUE;for(let t=d;t<p;++t)for(let a=0;a<l;++a)y.RectangleGeometryLibrary.computePosition(e,o,n.st,t,a,x,w),h[_++]=x.x,h[_++]=x.y,h[_++]=x.z,n.st&&(b[A++]=w.x,b[A++]=w.y,C=Math.min(C,w.x),v=Math.min(v,w.y),R=Math.max(R,w.x),E=Math.max(E,w.y));if(u&&(y.RectangleGeometryLibrary.computePosition(e,o,n.st,0,0,x,w),h[_++]=x.x,h[_++]=x.y,h[_++]=x.z,n.st&&(b[A++]=w.x,b[A++]=w.y,C=w.x,v=w.y,R=w.x,E=w.y)),c&&(y.RectangleGeometryLibrary.computePosition(e,o,n.st,s-1,0,x,w),h[_++]=x.x,h[_++]=x.y,h[_]=x.z,n.st&&(b[A++]=w.x,b[A]=w.y,C=Math.min(C,w.x),v=Math.min(v,w.y),R=Math.max(R,w.x),E=Math.max(E,w.y))),n.st&&(C<0||v<0||R>1||E>1))for(let t=0;t<b.length;t+=2)b[t]=(b[t]-C)/(R-C),b[t+1]=(b[t+1]-v)/(E-v);const G=function(t,e,n,o){const r=t.length,i=e.normal?new Float32Array(r):void 0,s=e.tangent?new Float32Array(r):void 0,l=e.bitangent?new Float32Array(r):void 0;let u=0;const c=L,m=V;let d=P;if(e.normal||e.tangent||e.bitangent)for(let p=0;p<r;p+=3){const r=a.Cartesian3.fromArray(t,p,F),g=u+1,y=u+2;d=n.geodeticSurfaceNormal(r,d),(e.tangent||e.bitangent)&&(a.Cartesian3.cross(a.Cartesian3.UNIT_Z,d,m),a.Matrix3.multiplyByVector(o,m,m),a.Cartesian3.normalize(m,m),e.bitangent&&a.Cartesian3.normalize(a.Cartesian3.cross(d,m,c),c)),e.normal&&(i[u]=d.x,i[g]=d.y,i[y]=d.z),e.tangent&&(s[u]=m.x,s[g]=m.y,s[y]=m.z),e.bitangent&&(l[u]=c.x,l[g]=c.y,l[y]=c.z),u+=3}return N(e,{positions:t,normals:i,tangents:s,bitangents:l})}(h,n,o,e.tangentRotationMatrix);let D=6*(l-1)*(g-1);u&&(D+=3*(l-1)),c&&(D+=3*(l-1));const T=m.IndexDatatype.createTypedArray(f,D);let O,S=0,I=0;for(O=0;O<g-1;++O){for(let t=0;t<l-1;++t){const t=S,e=t+l,n=e+1,a=t+1;T[I++]=t,T[I++]=e,T[I++]=a,T[I++]=a,T[I++]=e,T[I++]=n,++S}++S}if(u||c){let t=f-1;const e=f-1;let n,a;if(u&&c&&(t=f-2),S=0,u)for(O=0;O<l-1;O++)n=S,a=n+1,T[I++]=t,T[I++]=n,T[I++]=a,++S;if(c)for(S=(g-1)*l,O=0;O<l-1;O++)n=S,a=n+1,T[I++]=n,T[I++]=e,T[I++]=a,++S}return G.indices=T,n.st&&(G.attributes.st=new i.GeometryAttribute({componentDatatype:r.ComponentDatatype.FLOAT,componentsPerAttribute:2,values:b})),G}function H(t,e,n,a,o){return t[e++]=a[n],t[e++]=a[n+1],t[e++]=a[n+2],t[e++]=o[n],t[e++]=o[n+1],t[e]=o[n+2],t}function z(t,e,n,a){return t[e++]=a[n],t[e++]=a[n+1],t[e++]=a[n],t[e]=a[n+1],t}const B=new f.VertexFormat;function U(e,n){const o=e._shadowVolume,s=e._offsetAttribute,p=e._vertexFormat,y=e._extrudedHeight,h=e._surfaceHeight,b=e._ellipsoid,_=n.height,A=n.width;let x;if(o){const t=f.VertexFormat.clone(p,B);t.normal=!0,e._vertexFormat=t}const w=k(e,n);o&&(e._vertexFormat=p);let C=g.PolygonPipeline.scaleToGeodeticHeight(w.attributes.position.values,h,b,!1);C=new Float64Array(C);let v=C.length;const R=2*v,E=new Float64Array(R);E.set(C);const G=g.PolygonPipeline.scaleToGeodeticHeight(w.attributes.position.values,y,b);E.set(G,v),w.attributes.position.values=E;const D=p.normal?new Float32Array(R):void 0,M=p.tangent?new Float32Array(R):void 0,T=p.bitangent?new Float32Array(R):void 0,O=p.st?new Float32Array(R/3*2):void 0;let U,Y,q;if(p.normal){for(Y=w.attributes.normal.values,D.set(Y),x=0;x<v;x++)Y[x]=-Y[x];D.set(Y,v),w.attributes.normal.values=D}if(o){Y=w.attributes.normal.values,p.normal||(w.attributes.normal=void 0);const t=new Float32Array(R);for(x=0;x<v;x++)Y[x]=-Y[x];t.set(Y,v),w.attributes.extrudeDirection=new i.GeometryAttribute({componentDatatype:r.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:t})}const X=t.defined(s);if(X){const t=v/3*2;let e=new Uint8Array(t);s===u.GeometryOffsetAttribute.TOP?e=e.fill(1,0,t/2):(q=s===u.GeometryOffsetAttribute.NONE?0:1,e=e.fill(q)),w.attributes.applyOffset=new i.GeometryAttribute({componentDatatype:r.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:e})}if(p.tangent){const t=w.attributes.tangent.values;for(M.set(t),x=0;x<v;x++)t[x]=-t[x];M.set(t,v),w.attributes.tangent.values=M}if(p.bitangent){const t=w.attributes.bitangent.values;T.set(t),T.set(t,v),w.attributes.bitangent.values=T}p.st&&(U=w.attributes.st.values,O.set(U),O.set(U,v/3*2),w.attributes.st.values=O);const Q=w.indices,W=Q.length,j=v/3,J=m.IndexDatatype.createTypedArray(R/3,2*W);for(J.set(Q),x=0;x<W;x+=3)J[x+W]=Q[x+2]+j,J[x+1+W]=Q[x+1]+j,J[x+2+W]=Q[x]+j;w.indices=J;const Z=n.northCap,K=n.southCap;let $=_,tt=2,et=0,nt=4,at=4;Z&&(tt-=1,$-=1,et+=1,nt-=2,at-=1),K&&(tt-=1,$-=1,et+=1,nt-=2,at-=1),et+=tt*A+2*$-nt;const ot=2*(et+at);let rt=new Float64Array(3*ot);const it=o?new Float32Array(3*ot):void 0;let st=X?new Uint8Array(ot):void 0,lt=p.st?new Float32Array(2*ot):void 0;const ut=s===u.GeometryOffsetAttribute.TOP;X&&!ut&&(q=s===u.GeometryOffsetAttribute.ALL?1:0,st=st.fill(q));let ct=0,mt=0,dt=0,pt=0;const gt=A*$;let yt;for(x=0;x<gt;x+=A)yt=3*x,rt=H(rt,ct,yt,C,G),ct+=6,p.st&&(lt=z(lt,mt,2*x,U),mt+=4),o&&(dt+=3,it[dt++]=Y[yt],it[dt++]=Y[yt+1],it[dt++]=Y[yt+2]),ut&&(st[pt++]=1,pt+=1);if(K){const t=Z?gt+1:gt;for(yt=3*t,x=0;x<2;x++)rt=H(rt,ct,yt,C,G),ct+=6,p.st&&(lt=z(lt,mt,2*t,U),mt+=4),o&&(dt+=3,it[dt++]=Y[yt],it[dt++]=Y[yt+1],it[dt++]=Y[yt+2]),ut&&(st[pt++]=1,pt+=1)}else for(x=gt-A;x<gt;x++)yt=3*x,rt=H(rt,ct,yt,C,G),ct+=6,p.st&&(lt=z(lt,mt,2*x,U),mt+=4),o&&(dt+=3,it[dt++]=Y[yt],it[dt++]=Y[yt+1],it[dt++]=Y[yt+2]),ut&&(st[pt++]=1,pt+=1);for(x=gt-1;x>0;x-=A)yt=3*x,rt=H(rt,ct,yt,C,G),ct+=6,p.st&&(lt=z(lt,mt,2*x,U),mt+=4),o&&(dt+=3,it[dt++]=Y[yt],it[dt++]=Y[yt+1],it[dt++]=Y[yt+2]),ut&&(st[pt++]=1,pt+=1);if(Z){const t=gt;for(yt=3*t,x=0;x<2;x++)rt=H(rt,ct,yt,C,G),ct+=6,p.st&&(lt=z(lt,mt,2*t,U),mt+=4),o&&(dt+=3,it[dt++]=Y[yt],it[dt++]=Y[yt+1],it[dt++]=Y[yt+2]),ut&&(st[pt++]=1,pt+=1)}else for(x=A-1;x>=0;x--)yt=3*x,rt=H(rt,ct,yt,C,G),ct+=6,p.st&&(lt=z(lt,mt,2*x,U),mt+=4),o&&(dt+=3,it[dt++]=Y[yt],it[dt++]=Y[yt+1],it[dt++]=Y[yt+2]),ut&&(st[pt++]=1,pt+=1);let ft=function(t,e,n){const o=t.length,r=e.normal?new Float32Array(o):void 0,i=e.tangent?new Float32Array(o):void 0,s=e.bitangent?new Float32Array(o):void 0;let l=0,u=0,c=0,m=!0,p=L,g=V,y=P;if(e.normal||e.tangent||e.bitangent)for(let f=0;f<o;f+=6){const h=a.Cartesian3.fromArray(t,f,F),b=a.Cartesian3.fromArray(t,(f+6)%o,S);if(m){const e=a.Cartesian3.fromArray(t,(f+3)%o,I);a.Cartesian3.subtract(b,h,b),a.Cartesian3.subtract(e,h,e),y=a.Cartesian3.normalize(a.Cartesian3.cross(e,b,y),y),m=!1}a.Cartesian3.equalsEpsilon(b,h,d.CesiumMath.EPSILON10)&&(m=!0),(e.tangent||e.bitangent)&&(p=n.geodeticSurfaceNormal(h,p),e.tangent&&(g=a.Cartesian3.normalize(a.Cartesian3.cross(p,y,g),g))),e.normal&&(r[l++]=y.x,r[l++]=y.y,r[l++]=y.z,r[l++]=y.x,r[l++]=y.y,r[l++]=y.z),e.tangent&&(i[u++]=g.x,i[u++]=g.y,i[u++]=g.z,i[u++]=g.x,i[u++]=g.y,i[u++]=g.z),e.bitangent&&(s[c++]=p.x,s[c++]=p.y,s[c++]=p.z,s[c++]=p.x,s[c++]=p.y,s[c++]=p.z)}return N(e,{positions:t,normals:r,tangents:i,bitangents:s})}(rt,p,b);p.st&&(ft.attributes.st=new i.GeometryAttribute({componentDatatype:r.ComponentDatatype.FLOAT,componentsPerAttribute:2,values:lt})),o&&(ft.attributes.extrudeDirection=new i.GeometryAttribute({componentDatatype:r.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:it})),X&&(ft.attributes.applyOffset=new i.GeometryAttribute({componentDatatype:r.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:st}));const ht=m.IndexDatatype.createTypedArray(ot,6*et);let bt,_t,At,xt;v=rt.length/3;let wt=0;for(x=0;x<v-1;x+=2){bt=x,xt=(bt+2)%v;const t=a.Cartesian3.fromArray(rt,3*bt,S),e=a.Cartesian3.fromArray(rt,3*xt,I);a.Cartesian3.equalsEpsilon(t,e,d.CesiumMath.EPSILON10)||(_t=(bt+1)%v,At=(_t+2)%v,ht[wt++]=bt,ht[wt++]=_t,ht[wt++]=xt,ht[wt++]=xt,ht[wt++]=_t,ht[wt++]=At)}return ft.indices=ht,ft=c.GeometryPipeline.combineInstances([new l.GeometryInstance({geometry:w}),new l.GeometryInstance({geometry:ft})]),ft[0]}const Y=[new a.Cartesian3,new a.Cartesian3,new a.Cartesian3,new a.Cartesian3],q=new a.Cartographic,X=new a.Cartographic;function Q(t,n,a,o,r){if(0===a)return e.Rectangle.clone(t,r);const i=y.RectangleGeometryLibrary.computeOptions(t,n,a,0,D,q),s=i.height,l=i.width,u=Y;return y.RectangleGeometryLibrary.computePosition(i,o,!1,0,0,u[0]),y.RectangleGeometryLibrary.computePosition(i,o,!1,0,l-1,u[1]),y.RectangleGeometryLibrary.computePosition(i,o,!1,s-1,0,u[2]),y.RectangleGeometryLibrary.computePosition(i,o,!1,s-1,l-1,u[3]),e.Rectangle.fromCartesianArray(u,o,r)}function W(n){const a=(n=t.defaultValue(n,t.defaultValue.EMPTY_OBJECT)).rectangle,o=t.defaultValue(n.height,0),r=t.defaultValue(n.extrudedHeight,o);this._rectangle=e.Rectangle.clone(a),this._granularity=t.defaultValue(n.granularity,d.CesiumMath.RADIANS_PER_DEGREE),this._ellipsoid=e.Ellipsoid.clone(t.defaultValue(n.ellipsoid,e.Ellipsoid.WGS84)),this._surfaceHeight=Math.max(o,r),this._rotation=t.defaultValue(n.rotation,0),this._stRotation=t.defaultValue(n.stRotation,0),this._vertexFormat=f.VertexFormat.clone(t.defaultValue(n.vertexFormat,f.VertexFormat.DEFAULT)),this._extrudedHeight=Math.min(o,r),this._shadowVolume=t.defaultValue(n.shadowVolume,!1),this._workerName="createRectangleGeometry",this._offsetAttribute=n.offsetAttribute,this._rotatedRectangle=void 0,this._textureCoordinateRotationPoints=void 0}W.packedLength=e.Rectangle.packedLength+e.Ellipsoid.packedLength+f.VertexFormat.packedLength+7,W.pack=function(n,a,o){return o=t.defaultValue(o,0),e.Rectangle.pack(n._rectangle,a,o),o+=e.Rectangle.packedLength,e.Ellipsoid.pack(n._ellipsoid,a,o),o+=e.Ellipsoid.packedLength,f.VertexFormat.pack(n._vertexFormat,a,o),o+=f.VertexFormat.packedLength,a[o++]=n._granularity,a[o++]=n._surfaceHeight,a[o++]=n._rotation,a[o++]=n._stRotation,a[o++]=n._extrudedHeight,a[o++]=n._shadowVolume?1:0,a[o]=t.defaultValue(n._offsetAttribute,-1),a};const j=new e.Rectangle,J=e.Ellipsoid.clone(e.Ellipsoid.UNIT_SPHERE),Z={rectangle:j,ellipsoid:J,vertexFormat:B,granularity:void 0,height:void 0,rotation:void 0,stRotation:void 0,extrudedHeight:void 0,shadowVolume:void 0,offsetAttribute:void 0};W.unpack=function(n,a,o){a=t.defaultValue(a,0);const r=e.Rectangle.unpack(n,a,j);a+=e.Rectangle.packedLength;const i=e.Ellipsoid.unpack(n,a,J);a+=e.Ellipsoid.packedLength;const s=f.VertexFormat.unpack(n,a,B);a+=f.VertexFormat.packedLength;const l=n[a++],u=n[a++],c=n[a++],m=n[a++],d=n[a++],p=1===n[a++],g=n[a];return t.defined(o)?(o._rectangle=e.Rectangle.clone(r,o._rectangle),o._ellipsoid=e.Ellipsoid.clone(i,o._ellipsoid),o._vertexFormat=f.VertexFormat.clone(s,o._vertexFormat),o._granularity=l,o._surfaceHeight=u,o._rotation=c,o._stRotation=m,o._extrudedHeight=d,o._shadowVolume=p,o._offsetAttribute=-1===g?void 0:g,o):(Z.granularity=l,Z.height=u,Z.rotation=c,Z.stRotation=m,Z.extrudedHeight=d,Z.shadowVolume=p,Z.offsetAttribute=-1===g?void 0:g,new W(Z))},W.computeRectangle=function(n,a){const o=(n=t.defaultValue(n,t.defaultValue.EMPTY_OBJECT)).rectangle,r=t.defaultValue(n.granularity,d.CesiumMath.RADIANS_PER_DEGREE),i=t.defaultValue(n.ellipsoid,e.Ellipsoid.WGS84);return Q(o,r,t.defaultValue(n.rotation,0),i,a)};const K=new a.Matrix3,$=new n.Quaternion,tt=new a.Cartographic;W.createGeometry=function(o){if(d.CesiumMath.equalsEpsilon(o._rectangle.north,o._rectangle.south,d.CesiumMath.EPSILON10)||d.CesiumMath.equalsEpsilon(o._rectangle.east,o._rectangle.west,d.CesiumMath.EPSILON10))return;let s=o._rectangle;const l=o._ellipsoid,c=o._rotation,m=o._stRotation,p=o._vertexFormat,f=y.RectangleGeometryLibrary.computeOptions(s,o._granularity,c,m,D,q,X),h=K;if(0!==m||0!==c){const t=e.Rectangle.center(s,tt),o=l.geodeticSurfaceNormalCartographic(t,S);n.Quaternion.fromAxisAngle(o,-m,$),a.Matrix3.fromQuaternion($,h)}else a.Matrix3.clone(a.Matrix3.IDENTITY,h);const b=o._surfaceHeight,_=o._extrudedHeight,A=!d.CesiumMath.equalsEpsilon(b,_,0,d.CesiumMath.EPSILON2);let x,w;if(f.lonScalar=1/o._rectangle.width,f.latScalar=1/o._rectangle.height,f.tangentRotationMatrix=h,s=o._rectangle,A){x=U(o,f);const t=n.BoundingSphere.fromRectangle3D(s,l,b,O),e=n.BoundingSphere.fromRectangle3D(s,l,_,T);w=n.BoundingSphere.union(t,e)}else{if(x=k(o,f),x.attributes.position.values=g.PolygonPipeline.scaleToGeodeticHeight(x.attributes.position.values,b,l,!1),t.defined(o._offsetAttribute)){const t=x.attributes.position.values.length,e=o._offsetAttribute===u.GeometryOffsetAttribute.NONE?0:1,n=new Uint8Array(t/3).fill(e);x.attributes.applyOffset=new i.GeometryAttribute({componentDatatype:r.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:n})}w=n.BoundingSphere.fromRectangle3D(s,l,b)}return p.position||delete x.attributes.position,new i.Geometry({attributes:x.attributes,indices:x.indices,primitiveType:x.primitiveType,boundingSphere:w,offsetAttribute:o._offsetAttribute})},W.createShadowVolume=function(t,e,n){const a=t._granularity,o=t._ellipsoid,r=e(a,o),i=n(a,o);return new W({rectangle:t._rectangle,rotation:t._rotation,ellipsoid:o,stRotation:t._stRotation,granularity:a,extrudedHeight:i,height:r,vertexFormat:f.VertexFormat.POSITION_ONLY,shadowVolume:!0})};const et=new e.Rectangle,nt=[new a.Cartesian2,new a.Cartesian2,new a.Cartesian2],at=new p.Matrix2,ot=new a.Cartographic;return Object.defineProperties(W.prototype,{rectangle:{get:function(){return t.defined(this._rotatedRectangle)||(this._rotatedRectangle=Q(this._rectangle,this._granularity,this._rotation,this._ellipsoid)),this._rotatedRectangle}},textureCoordinateRotationPoints:{get:function(){return t.defined(this._textureCoordinateRotationPoints)||(this._textureCoordinateRotationPoints=function(t){if(0===t._stRotation)return[0,0,0,1,1,0];const n=e.Rectangle.clone(t._rectangle,et),o=t._granularity,r=t._ellipsoid,i=Q(n,o,t._rotation-t._stRotation,r,et),s=nt;s[0].x=i.west,s[0].y=i.south,s[1].x=i.west,s[1].y=i.north,s[2].x=i.east,s[2].y=i.south;const l=t.rectangle,u=p.Matrix2.fromRotation(t._stRotation,at),c=e.Rectangle.center(l,ot);for(let t=0;t<3;++t){const e=s[t];e.x-=c.longitude,e.y-=c.latitude,p.Matrix2.multiplyByVector(u,e,e),e.x+=c.longitude,e.y+=c.latitude,e.x=(e.x-l.west)/l.width,e.y=(e.y-l.south)/l.height}const m=s[0],d=s[1],g=s[2],y=new Array(6);return a.Cartesian2.pack(m,y),a.Cartesian2.pack(d,y,2),a.Cartesian2.pack(g,y,4),y}(this)),this._textureCoordinateRotationPoints}}}),function(n,a){return t.defined(a)&&(n=W.unpack(n,a)),n._ellipsoid=e.Ellipsoid.clone(n._ellipsoid),n._rectangle=e.Rectangle.clone(n._rectangle),W.createGeometry(n)}}));
