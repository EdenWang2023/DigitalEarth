/**
 * @license
 * Cesium - https://github.com/CesiumGS/cesium
 * Version 1.96
 *
 * Copyright 2011-2022 Cesium Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Columbus View (Pat. Pend.)
 *
 * Portions licensed separately.
 * See https://github.com/CesiumGS/cesium/blob/main/LICENSE.md for full licensing details.
 */
define(["./AttributeCompression-055d015a","./Transforms-99c89742","./Matrix4-d3db9505","./defined-b681f02d","./Rectangle-0610a1c7","./TerrainEncoding-a8569660","./IndexDatatype-1b44a4e6","./Check-436535f3","./Math-5b6faca9","./OrientedBoundingBox-4ee28786","./createTaskProcessorWorker","./ComponentDatatype-46a1cf7a","./WebGLConstants-f100e3dd","./Matrix2-7384588e","./Interval-49d6e8fc","./_commonjsHelpers-a32ac251","./combine-8b9ba6cb","./RequestType-e53aab71","./RuntimeError-14317824","./TerrainQuantization-3ae29896","./EllipsoidTangentPlane-34e5c0ac","./AxisAlignedBoundingBox-321a482b","./IntersectionTests-3ac7f0c9","./Plane-172c23d7"],(function(e,t,n,i,s,r,h,o,u,d,p,a,l,c,f,g,m,x,w,C,y,B,I,b){"use strict";const A={clipTriangleAtAxisAlignedThreshold:function(e,t,n,s,r,h){let o,u,d;i.defined(h)?h.length=0:h=[],t?(o=n<e,u=s<e,d=r<e):(o=n>e,u=s>e,d=r>e);const p=o+u+d;let a,l,c,f,g,m;return 1===p?o?(a=(e-n)/(s-n),l=(e-n)/(r-n),h.push(1),h.push(2),1!==l&&(h.push(-1),h.push(0),h.push(2),h.push(l)),1!==a&&(h.push(-1),h.push(0),h.push(1),h.push(a))):u?(c=(e-s)/(r-s),f=(e-s)/(n-s),h.push(2),h.push(0),1!==f&&(h.push(-1),h.push(1),h.push(0),h.push(f)),1!==c&&(h.push(-1),h.push(1),h.push(2),h.push(c))):d&&(g=(e-r)/(n-r),m=(e-r)/(s-r),h.push(0),h.push(1),1!==m&&(h.push(-1),h.push(2),h.push(1),h.push(m)),1!==g&&(h.push(-1),h.push(2),h.push(0),h.push(g))):2===p?o||n===e?u||s===e?d||r===e||(l=(e-n)/(r-n),c=(e-s)/(r-s),h.push(2),h.push(-1),h.push(0),h.push(2),h.push(l),h.push(-1),h.push(1),h.push(2),h.push(c)):(m=(e-r)/(s-r),a=(e-n)/(s-n),h.push(1),h.push(-1),h.push(2),h.push(1),h.push(m),h.push(-1),h.push(0),h.push(1),h.push(a)):(f=(e-s)/(n-s),g=(e-r)/(n-r),h.push(0),h.push(-1),h.push(1),h.push(0),h.push(f),h.push(-1),h.push(2),h.push(0),h.push(g)):3!==p&&(h.push(0),h.push(1),h.push(2)),h},computeBarycentricCoordinates:function(e,t,s,r,h,o,u,d,p){const a=s-u,l=u-h,c=o-d,f=r-d,g=1/(c*a+l*f),m=t-d,x=e-u,w=(c*x+l*m)*g,C=(-f*x+a*m)*g,y=1-w-C;return i.defined(p)?(p.x=w,p.y=C,p.z=y,p):new n.Cartesian3(w,C,y)},computeLineSegmentLineSegmentIntersection:function(e,t,s,r,h,o,u,d,p){const a=(d-o)*(s-e)-(u-h)*(r-t);if(0===a)return;const l=((u-h)*(t-o)-(d-o)*(e-h))/a,c=((s-e)*(t-o)-(r-t)*(e-h))/a;return l>=0&&l<=1&&c>=0&&c<=1?(i.defined(p)||(p=new n.Cartesian2),p.x=e+l*(s-e),p.y=t+l*(r-t),p):void 0}},v=32767,T=16383,z=[],M=[],N=[],V=new n.Cartographic;let R=new n.Cartesian3;const E=[],H=[],O=[],S=[],U=[],F=new n.Cartesian3,P=new t.BoundingSphere,k=new d.OrientedBoundingBox,D=new n.Cartesian2,W=new n.Cartesian3;function X(){this.vertexBuffer=void 0,this.index=void 0,this.first=void 0,this.second=void 0,this.ratio=void 0}X.prototype.clone=function(e){return i.defined(e)||(e=new X),e.uBuffer=this.uBuffer,e.vBuffer=this.vBuffer,e.heightBuffer=this.heightBuffer,e.normalBuffer=this.normalBuffer,e.index=this.index,e.first=this.first,e.second=this.second,e.ratio=this.ratio,e},X.prototype.initializeIndexed=function(e,t,n,i,s){this.uBuffer=e,this.vBuffer=t,this.heightBuffer=n,this.normalBuffer=i,this.index=s,this.first=void 0,this.second=void 0,this.ratio=void 0},X.prototype.initializeFromClipResult=function(e,t,n){let i=t+1;return-1!==e[t]?n[e[t]].clone(this):(this.vertexBuffer=void 0,this.index=void 0,this.first=n[e[i]],++i,this.second=n[e[i]],++i,this.ratio=e[i],++i),i},X.prototype.getKey=function(){return this.isIndexed()?this.index:JSON.stringify({first:this.first.getKey(),second:this.second.getKey(),ratio:this.ratio})},X.prototype.isIndexed=function(){return i.defined(this.index)},X.prototype.getH=function(){return i.defined(this.index)?this.heightBuffer[this.index]:u.CesiumMath.lerp(this.first.getH(),this.second.getH(),this.ratio)},X.prototype.getU=function(){return i.defined(this.index)?this.uBuffer[this.index]:u.CesiumMath.lerp(this.first.getU(),this.second.getU(),this.ratio)},X.prototype.getV=function(){return i.defined(this.index)?this.vBuffer[this.index]:u.CesiumMath.lerp(this.first.getV(),this.second.getV(),this.ratio)};let K=new n.Cartesian2,L=-1;const Y=[new n.Cartesian3,new n.Cartesian3],_=[new n.Cartesian3,new n.Cartesian3];function j(t,i){++L;let s=Y[L],r=_[L];return s=e.AttributeCompression.octDecode(t.first.getNormalX(),t.first.getNormalY(),s),r=e.AttributeCompression.octDecode(t.second.getNormalX(),t.second.getNormalY(),r),R=n.Cartesian3.lerp(s,r,t.ratio,R),n.Cartesian3.normalize(R,R),e.AttributeCompression.octEncode(R,i),--L,i}X.prototype.getNormalX=function(){return i.defined(this.index)?this.normalBuffer[2*this.index]:(K=j(this,K),K.x)},X.prototype.getNormalY=function(){return i.defined(this.index)?this.normalBuffer[2*this.index+1]:(K=j(this,K),K.y)};const q=[];function G(e,t,n,s,r,h,o,u,d){if(0===o.length)return;let p=0,a=0;for(;a<o.length;)a=q[p++].initializeFromClipResult(o,a,u);for(let r=0;r<p;++r){const o=q[r];if(o.isIndexed())o.newIndex=h[o.index],o.uBuffer=e,o.vBuffer=t,o.heightBuffer=n,d&&(o.normalBuffer=s);else{const r=o.getKey();if(i.defined(h[r]))o.newIndex=h[r];else{const i=e.length;e.push(o.getU()),t.push(o.getV()),n.push(o.getH()),d&&(s.push(o.getNormalX()),s.push(o.getNormalY())),o.newIndex=i,h[r]=i}}}3===p?(r.push(q[0].newIndex),r.push(q[1].newIndex),r.push(q[2].newIndex)):4===p&&(r.push(q[0].newIndex),r.push(q[1].newIndex),r.push(q[2].newIndex),r.push(q[0].newIndex),r.push(q[2].newIndex),r.push(q[3].newIndex))}return q.push(new X),q.push(new X),q.push(new X),q.push(new X),p((function(e,i){const o=e.isEastChild,p=e.isNorthChild,a=o?T:0,l=o?v:T,c=p?T:0,f=p?v:T,g=E,m=H,x=O,w=U;g.length=0,m.length=0,x.length=0,w.length=0;const C=S;C.length=0;const y={},B=e.vertices;let I=e.indices;I=I.subarray(0,e.indexCountWithoutSkirts);const b=r.TerrainEncoding.clone(e.encoding),K=b.hasVertexNormals;let L=0;const Y=e.vertexCountWithoutSkirts,_=e.minimumHeight,j=e.maximumHeight,q=new Array(Y),J=new Array(Y),Q=new Array(Y),Z=K?new Array(2*Y):void 0;let $,ee,te,ne,ie;for(ee=0,te=0;ee<Y;++ee,te+=2){const e=b.decodeTextureCoordinates(B,ee,D);if($=b.decodeHeight(B,ee),ne=u.CesiumMath.clamp(e.x*v|0,0,v),ie=u.CesiumMath.clamp(e.y*v|0,0,v),Q[ee]=u.CesiumMath.clamp(($-_)/(j-_)*v|0,0,v),ne<20&&(ne=0),ie<20&&(ie=0),v-ne<20&&(ne=v),v-ie<20&&(ie=v),q[ee]=ne,J[ee]=ie,K){const e=b.getOctEncodedNormal(B,ee,W);Z[te]=e.x,Z[te+1]=e.y}(o&&ne>=T||!o&&ne<=T)&&(p&&ie>=T||!p&&ie<=T)&&(y[ee]=L,g.push(ne),m.push(ie),x.push(Q[ee]),K&&(w.push(Z[te]),w.push(Z[te+1])),++L)}const se=[];se.push(new X),se.push(new X),se.push(new X);const re=[];let he,oe;for(re.push(new X),re.push(new X),re.push(new X),ee=0;ee<I.length;ee+=3){const e=I[ee],t=I[ee+1],n=I[ee+2],i=q[e],s=q[t],r=q[n];se[0].initializeIndexed(q,J,Q,Z,e),se[1].initializeIndexed(q,J,Q,Z,t),se[2].initializeIndexed(q,J,Q,Z,n);const h=A.clipTriangleAtAxisAlignedThreshold(T,o,i,s,r,z);he=0,he>=h.length||(he=re[0].initializeFromClipResult(h,he,se),he>=h.length||(he=re[1].initializeFromClipResult(h,he,se),he>=h.length||(he=re[2].initializeFromClipResult(h,he,se),oe=A.clipTriangleAtAxisAlignedThreshold(T,p,re[0].getV(),re[1].getV(),re[2].getV(),M),G(g,m,x,w,C,y,oe,re,K),he<h.length&&(re[2].clone(re[1]),re[2].initializeFromClipResult(h,he,se),oe=A.clipTriangleAtAxisAlignedThreshold(T,p,re[0].getV(),re[1].getV(),re[2].getV(),M),G(g,m,x,w,C,y,oe,re,K)))))}const ue=o?-32767:0,de=p?-32767:0,pe=[],ae=[],le=[],ce=[];let fe=Number.MAX_VALUE,ge=-fe;const me=N;me.length=0;const xe=s.Ellipsoid.clone(e.ellipsoid),we=s.Rectangle.clone(e.childRectangle),Ce=we.north,ye=we.south;let Be=we.east;const Ie=we.west;for(Be<Ie&&(Be+=u.CesiumMath.TWO_PI),ee=0;ee<g.length;++ee)ne=Math.round(g[ee]),ne<=a?(pe.push(ee),ne=0):ne>=l?(le.push(ee),ne=v):ne=2*ne+ue,g[ee]=ne,ie=Math.round(m[ee]),ie<=c?(ae.push(ee),ie=0):ie>=f?(ce.push(ee),ie=v):ie=2*ie+de,m[ee]=ie,$=u.CesiumMath.lerp(_,j,x[ee]/v),$<fe&&(fe=$),$>ge&&(ge=$),x[ee]=$,V.longitude=u.CesiumMath.lerp(Ie,Be,ne/v),V.latitude=u.CesiumMath.lerp(ye,Ce,ie/v),V.height=$,xe.cartographicToCartesian(V,R),me.push(R.x),me.push(R.y),me.push(R.z);const be=t.BoundingSphere.fromVertices(me,n.Cartesian3.ZERO,3,P),Ae=d.OrientedBoundingBox.fromRectangle(we,fe,ge,xe,k),ve=new r.EllipsoidalOccluder(xe).computeHorizonCullingPointFromVerticesPossiblyUnderEllipsoid(be.center,me,3,be.center,fe,F),Te=ge-fe,ze=new Uint16Array(g.length+m.length+x.length);for(ee=0;ee<g.length;++ee)ze[ee]=g[ee];let Me=g.length;for(ee=0;ee<m.length;++ee)ze[Me+ee]=m[ee];for(Me+=m.length,ee=0;ee<x.length;++ee)ze[Me+ee]=v*(x[ee]-fe)/Te;const Ne=h.IndexDatatype.createTypedArray(g.length,C);let Ve;if(K){const e=new Uint8Array(w);i.push(ze.buffer,Ne.buffer,e.buffer),Ve=e.buffer}else i.push(ze.buffer,Ne.buffer);return{vertices:ze.buffer,encodedNormals:Ve,indices:Ne.buffer,minimumHeight:fe,maximumHeight:ge,westIndices:pe,southIndices:ae,eastIndices:le,northIndices:ce,boundingSphere:be,orientedBoundingBox:Ae,horizonOcclusionPoint:ve}}))}));
