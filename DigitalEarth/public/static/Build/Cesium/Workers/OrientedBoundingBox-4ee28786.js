/**
 * @license
 * Cesium - https://github.com/CesiumGS/cesium
 * Version 1.96
 *
 * Copyright 2011-2022 Cesium Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Columbus View (Pat. Pend.)
 *
 * Portions licensed separately.
 * See https://github.com/CesiumGS/cesium/blob/main/LICENSE.md for full licensing details.
 */
define(["exports","./Transforms-99c89742","./Matrix4-d3db9505","./Check-436535f3","./defined-b681f02d","./Rectangle-0610a1c7","./EllipsoidTangentPlane-34e5c0ac","./Interval-49d6e8fc","./Math-5b6faca9","./Plane-172c23d7"],(function(a,t,e,n,r,i,s,o,c,C){"use strict";function u(a,t){this.center=e.Cartesian3.clone(r.defaultValue(a,e.Cartesian3.ZERO)),this.halfAxes=e.Matrix3.clone(r.defaultValue(t,e.Matrix3.ZERO))}u.packedLength=e.Cartesian3.packedLength+e.Matrix3.packedLength,u.pack=function(a,t,n){return n=r.defaultValue(n,0),e.Cartesian3.pack(a.center,t,n),e.Matrix3.pack(a.halfAxes,t,n+e.Cartesian3.packedLength),t},u.unpack=function(a,t,n){return t=r.defaultValue(t,0),r.defined(n)||(n=new u),e.Cartesian3.unpack(a,t,n.center),e.Matrix3.unpack(a,t+e.Cartesian3.packedLength,n.halfAxes),n};const l=new e.Cartesian3,d=new e.Cartesian3,h=new e.Cartesian3,x=new e.Cartesian3,m=new e.Cartesian3,f=new e.Cartesian3,M=new e.Matrix3,p={unitary:new e.Matrix3,diagonal:new e.Matrix3};u.fromPoints=function(a,t){if(r.defined(t)||(t=new u),!r.defined(a)||0===a.length)return t.halfAxes=e.Matrix3.ZERO,t.center=e.Cartesian3.ZERO,t;let n;const i=a.length,s=e.Cartesian3.clone(a[0],l);for(n=1;n<i;n++)e.Cartesian3.add(s,a[n],s);const o=1/i;e.Cartesian3.multiplyByScalar(s,o,s);let c,C=0,w=0,g=0,y=0,b=0,N=0;for(n=0;n<i;n++)c=e.Cartesian3.subtract(a[n],s,d),C+=c.x*c.x,w+=c.x*c.y,g+=c.x*c.z,y+=c.y*c.y,b+=c.y*c.z,N+=c.z*c.z;C*=o,w*=o,g*=o,y*=o,b*=o,N*=o;const T=M;T[0]=C,T[1]=w,T[2]=g,T[3]=w,T[4]=y,T[5]=b,T[6]=g,T[7]=b,T[8]=N;const O=e.Matrix3.computeEigenDecomposition(T,p),A=e.Matrix3.clone(O.unitary,t.halfAxes);let P=e.Matrix3.getColumn(A,0,x),I=e.Matrix3.getColumn(A,1,m),R=e.Matrix3.getColumn(A,2,f),E=-Number.MAX_VALUE,S=-Number.MAX_VALUE,U=-Number.MAX_VALUE,L=Number.MAX_VALUE,z=Number.MAX_VALUE,B=Number.MAX_VALUE;for(n=0;n<i;n++)c=a[n],E=Math.max(e.Cartesian3.dot(P,c),E),S=Math.max(e.Cartesian3.dot(I,c),S),U=Math.max(e.Cartesian3.dot(R,c),U),L=Math.min(e.Cartesian3.dot(P,c),L),z=Math.min(e.Cartesian3.dot(I,c),z),B=Math.min(e.Cartesian3.dot(R,c),B);P=e.Cartesian3.multiplyByScalar(P,.5*(L+E),P),I=e.Cartesian3.multiplyByScalar(I,.5*(z+S),I),R=e.Cartesian3.multiplyByScalar(R,.5*(B+U),R);const V=e.Cartesian3.add(P,I,t.center);e.Cartesian3.add(V,R,V);const _=h;return _.x=E-L,_.y=S-z,_.z=U-B,e.Cartesian3.multiplyByScalar(_,.5,_),e.Matrix3.multiplyByScale(t.halfAxes,_,t.halfAxes),t};const w=new e.Cartesian3,g=new e.Cartesian3;function y(a,t,n,i,s,o,c,C,l,d,h){r.defined(h)||(h=new u);const x=h.halfAxes;e.Matrix3.setColumn(x,0,t,x),e.Matrix3.setColumn(x,1,n,x),e.Matrix3.setColumn(x,2,i,x);let m=w;m.x=(s+o)/2,m.y=(c+C)/2,m.z=(l+d)/2;const f=g;f.x=(o-s)/2,f.y=(C-c)/2,f.z=(d-l)/2;const M=h.center;return m=e.Matrix3.multiplyByVector(x,m,m),e.Cartesian3.add(a,m,M),e.Matrix3.multiplyByScale(x,f,x),h}const b=new e.Cartographic,N=new e.Cartesian3,T=new e.Cartographic,O=new e.Cartographic,A=new e.Cartographic,P=new e.Cartographic,I=new e.Cartographic,R=new e.Cartesian3,E=new e.Cartesian3,S=new e.Cartesian3,U=new e.Cartesian3,L=new e.Cartesian3,z=new e.Cartesian2,B=new e.Cartesian2,V=new e.Cartesian2,_=new e.Cartesian2,k=new e.Cartesian2,W=new e.Cartesian3,X=new e.Cartesian3,q=new e.Cartesian3,D=new e.Cartesian3,j=new e.Cartesian2,Z=new e.Cartesian3,v=new e.Cartesian3,Y=new e.Cartesian3,G=new C.Plane(e.Cartesian3.UNIT_X,0);u.fromRectangle=function(a,t,n,o,u){let l,d,h,x,m,f,M;if(t=r.defaultValue(t,0),n=r.defaultValue(n,0),o=r.defaultValue(o,i.Ellipsoid.WGS84),a.width<=c.CesiumMath.PI){const r=i.Rectangle.center(a,b),c=o.cartographicToCartesian(r,N),p=new s.EllipsoidTangentPlane(c,o);M=p.plane;const w=r.longitude,g=a.south<0&&a.north>0?0:r.latitude,W=e.Cartographic.fromRadians(w,a.north,n,T),X=e.Cartographic.fromRadians(a.west,a.north,n,O),q=e.Cartographic.fromRadians(a.west,g,n,A),D=e.Cartographic.fromRadians(a.west,a.south,n,P),j=e.Cartographic.fromRadians(w,a.south,n,I),Z=o.cartographicToCartesian(W,R);let v=o.cartographicToCartesian(X,E);const Y=o.cartographicToCartesian(q,S);let G=o.cartographicToCartesian(D,U);const F=o.cartographicToCartesian(j,L),H=p.projectPointToNearestOnPlane(Z,z),J=p.projectPointToNearestOnPlane(v,B),K=p.projectPointToNearestOnPlane(Y,V),Q=p.projectPointToNearestOnPlane(G,_),$=p.projectPointToNearestOnPlane(F,k);return l=Math.min(J.x,K.x,Q.x),d=-l,x=Math.max(J.y,H.y),h=Math.min(Q.y,$.y),X.height=D.height=t,v=o.cartographicToCartesian(X,E),G=o.cartographicToCartesian(D,U),m=Math.min(C.Plane.getPointDistance(M,v),C.Plane.getPointDistance(M,G)),f=n,y(p.origin,p.xAxis,p.yAxis,p.zAxis,l,d,h,x,m,f,u)}const p=a.south>0,w=a.north<0,g=p?a.south:w?a.north:0,F=i.Rectangle.center(a,b).longitude,H=e.Cartesian3.fromRadians(F,g,n,o,W);H.z=0;const J=Math.abs(H.x)<c.CesiumMath.EPSILON10&&Math.abs(H.y)<c.CesiumMath.EPSILON10?e.Cartesian3.UNIT_X:e.Cartesian3.normalize(H,X),K=e.Cartesian3.UNIT_Z,Q=e.Cartesian3.cross(J,K,q);M=C.Plane.fromPointNormal(H,J,G);const $=e.Cartesian3.fromRadians(F+c.CesiumMath.PI_OVER_TWO,g,n,o,D);d=e.Cartesian3.dot(C.Plane.projectPointOntoPlane(M,$,j),Q),l=-d,x=e.Cartesian3.fromRadians(0,a.north,w?t:n,o,Z).z,h=e.Cartesian3.fromRadians(0,a.south,p?t:n,o,v).z;const aa=e.Cartesian3.fromRadians(a.east,g,n,o,Y);return m=C.Plane.getPointDistance(M,aa),f=0,y(H,Q,K,J,l,d,h,x,m,f,u)},u.fromTransformation=function(a,t){return r.defined(t)||(t=new u),t.center=e.Matrix4.getTranslation(a,t.center),t.halfAxes=e.Matrix4.getMatrix3(a,t.halfAxes),t.halfAxes=e.Matrix3.multiplyByScalar(t.halfAxes,.5,t.halfAxes),t},u.clone=function(a,t){if(r.defined(a))return r.defined(t)?(e.Cartesian3.clone(a.center,t.center),e.Matrix3.clone(a.halfAxes,t.halfAxes),t):new u(a.center,a.halfAxes)},u.intersectPlane=function(a,n){const r=a.center,i=n.normal,s=a.halfAxes,o=i.x,c=i.y,C=i.z,u=Math.abs(o*s[e.Matrix3.COLUMN0ROW0]+c*s[e.Matrix3.COLUMN0ROW1]+C*s[e.Matrix3.COLUMN0ROW2])+Math.abs(o*s[e.Matrix3.COLUMN1ROW0]+c*s[e.Matrix3.COLUMN1ROW1]+C*s[e.Matrix3.COLUMN1ROW2])+Math.abs(o*s[e.Matrix3.COLUMN2ROW0]+c*s[e.Matrix3.COLUMN2ROW1]+C*s[e.Matrix3.COLUMN2ROW2]),l=e.Cartesian3.dot(i,r)+n.distance;return l<=-u?t.Intersect.OUTSIDE:l>=u?t.Intersect.INSIDE:t.Intersect.INTERSECTING};const F=new e.Cartesian3,H=new e.Cartesian3,J=new e.Cartesian3,K=new e.Cartesian3,Q=new e.Cartesian3,$=new e.Cartesian3;u.distanceSquaredTo=function(a,t){const n=e.Cartesian3.subtract(t,a.center,w),r=a.halfAxes;let i=e.Matrix3.getColumn(r,0,F),s=e.Matrix3.getColumn(r,1,H),o=e.Matrix3.getColumn(r,2,J);const C=e.Cartesian3.magnitude(i),u=e.Cartesian3.magnitude(s),l=e.Cartesian3.magnitude(o);let d=!0,h=!0,x=!0;C>0?e.Cartesian3.divideByScalar(i,C,i):d=!1,u>0?e.Cartesian3.divideByScalar(s,u,s):h=!1,l>0?e.Cartesian3.divideByScalar(o,l,o):x=!1;const m=!d+!h+!x;let f,M,p;if(1===m){let a=i;f=s,M=o,h?x||(a=o,M=i):(a=s,f=i),p=e.Cartesian3.cross(f,M,Q),a===i?i=p:a===s?s=p:a===o&&(o=p)}else if(2===m){f=i,h?f=s:x&&(f=o);let a=e.Cartesian3.UNIT_Y;a.equalsEpsilon(f,c.CesiumMath.EPSILON3)&&(a=e.Cartesian3.UNIT_X),M=e.Cartesian3.cross(f,a,K),e.Cartesian3.normalize(M,M),p=e.Cartesian3.cross(f,M,Q),e.Cartesian3.normalize(p,p),f===i?(s=M,o=p):f===s?(o=M,i=p):f===o&&(i=M,s=p)}else 3===m&&(i=e.Cartesian3.UNIT_X,s=e.Cartesian3.UNIT_Y,o=e.Cartesian3.UNIT_Z);const g=$;g.x=e.Cartesian3.dot(n,i),g.y=e.Cartesian3.dot(n,s),g.z=e.Cartesian3.dot(n,o);let y,b=0;return g.x<-C?(y=g.x+C,b+=y*y):g.x>C&&(y=g.x-C,b+=y*y),g.y<-u?(y=g.y+u,b+=y*y):g.y>u&&(y=g.y-u,b+=y*y),g.z<-l?(y=g.z+l,b+=y*y):g.z>l&&(y=g.z-l,b+=y*y),b};const aa=new e.Cartesian3,ta=new e.Cartesian3;u.computePlaneDistances=function(a,t,n,i){r.defined(i)||(i=new o.Interval);let s=Number.POSITIVE_INFINITY,c=Number.NEGATIVE_INFINITY;const C=a.center,u=a.halfAxes,l=e.Matrix3.getColumn(u,0,F),d=e.Matrix3.getColumn(u,1,H),h=e.Matrix3.getColumn(u,2,J),x=e.Cartesian3.add(l,d,aa);e.Cartesian3.add(x,h,x),e.Cartesian3.add(x,C,x);const m=e.Cartesian3.subtract(x,t,ta);let f=e.Cartesian3.dot(n,m);return s=Math.min(f,s),c=Math.max(f,c),e.Cartesian3.add(C,l,x),e.Cartesian3.add(x,d,x),e.Cartesian3.subtract(x,h,x),e.Cartesian3.subtract(x,t,m),f=e.Cartesian3.dot(n,m),s=Math.min(f,s),c=Math.max(f,c),e.Cartesian3.add(C,l,x),e.Cartesian3.subtract(x,d,x),e.Cartesian3.add(x,h,x),e.Cartesian3.subtract(x,t,m),f=e.Cartesian3.dot(n,m),s=Math.min(f,s),c=Math.max(f,c),e.Cartesian3.add(C,l,x),e.Cartesian3.subtract(x,d,x),e.Cartesian3.subtract(x,h,x),e.Cartesian3.subtract(x,t,m),f=e.Cartesian3.dot(n,m),s=Math.min(f,s),c=Math.max(f,c),e.Cartesian3.subtract(C,l,x),e.Cartesian3.add(x,d,x),e.Cartesian3.add(x,h,x),e.Cartesian3.subtract(x,t,m),f=e.Cartesian3.dot(n,m),s=Math.min(f,s),c=Math.max(f,c),e.Cartesian3.subtract(C,l,x),e.Cartesian3.add(x,d,x),e.Cartesian3.subtract(x,h,x),e.Cartesian3.subtract(x,t,m),f=e.Cartesian3.dot(n,m),s=Math.min(f,s),c=Math.max(f,c),e.Cartesian3.subtract(C,l,x),e.Cartesian3.subtract(x,d,x),e.Cartesian3.add(x,h,x),e.Cartesian3.subtract(x,t,m),f=e.Cartesian3.dot(n,m),s=Math.min(f,s),c=Math.max(f,c),e.Cartesian3.subtract(C,l,x),e.Cartesian3.subtract(x,d,x),e.Cartesian3.subtract(x,h,x),e.Cartesian3.subtract(x,t,m),f=e.Cartesian3.dot(n,m),s=Math.min(f,s),c=Math.max(f,c),i.start=s,i.stop=c,i};const ea=new e.Cartesian3,na=new e.Cartesian3,ra=new e.Cartesian3;u.computeCorners=function(a,t){r.defined(t)||(t=[new e.Cartesian3,new e.Cartesian3,new e.Cartesian3,new e.Cartesian3,new e.Cartesian3,new e.Cartesian3,new e.Cartesian3,new e.Cartesian3]);const n=a.center,i=a.halfAxes,s=e.Matrix3.getColumn(i,0,ea),o=e.Matrix3.getColumn(i,1,na),c=e.Matrix3.getColumn(i,2,ra);return e.Cartesian3.clone(n,t[0]),e.Cartesian3.subtract(t[0],s,t[0]),e.Cartesian3.subtract(t[0],o,t[0]),e.Cartesian3.subtract(t[0],c,t[0]),e.Cartesian3.clone(n,t[1]),e.Cartesian3.subtract(t[1],s,t[1]),e.Cartesian3.subtract(t[1],o,t[1]),e.Cartesian3.add(t[1],c,t[1]),e.Cartesian3.clone(n,t[2]),e.Cartesian3.subtract(t[2],s,t[2]),e.Cartesian3.add(t[2],o,t[2]),e.Cartesian3.subtract(t[2],c,t[2]),e.Cartesian3.clone(n,t[3]),e.Cartesian3.subtract(t[3],s,t[3]),e.Cartesian3.add(t[3],o,t[3]),e.Cartesian3.add(t[3],c,t[3]),e.Cartesian3.clone(n,t[4]),e.Cartesian3.add(t[4],s,t[4]),e.Cartesian3.subtract(t[4],o,t[4]),e.Cartesian3.subtract(t[4],c,t[4]),e.Cartesian3.clone(n,t[5]),e.Cartesian3.add(t[5],s,t[5]),e.Cartesian3.subtract(t[5],o,t[5]),e.Cartesian3.add(t[5],c,t[5]),e.Cartesian3.clone(n,t[6]),e.Cartesian3.add(t[6],s,t[6]),e.Cartesian3.add(t[6],o,t[6]),e.Cartesian3.subtract(t[6],c,t[6]),e.Cartesian3.clone(n,t[7]),e.Cartesian3.add(t[7],s,t[7]),e.Cartesian3.add(t[7],o,t[7]),e.Cartesian3.add(t[7],c,t[7]),t};const ia=new e.Matrix3;u.computeTransformation=function(a,t){r.defined(t)||(t=new e.Matrix4);const n=a.center,i=e.Matrix3.multiplyByUniformScale(a.halfAxes,2,ia);return e.Matrix4.fromRotationTranslation(i,n,t)};const sa=new t.BoundingSphere;u.isOccluded=function(a,e){const n=t.BoundingSphere.fromOrientedBoundingBox(a,sa);return!e.isBoundingSphereVisible(n)},u.prototype.intersectPlane=function(a){return u.intersectPlane(this,a)},u.prototype.distanceSquaredTo=function(a){return u.distanceSquaredTo(this,a)},u.prototype.computePlaneDistances=function(a,t,e){return u.computePlaneDistances(this,a,t,e)},u.prototype.computeCorners=function(a){return u.computeCorners(this,a)},u.prototype.computeTransformation=function(a){return u.computeTransformation(this,a)},u.prototype.isOccluded=function(a){return u.isOccluded(this,a)},u.equals=function(a,t){return a===t||r.defined(a)&&r.defined(t)&&e.Cartesian3.equals(a.center,t.center)&&e.Matrix3.equals(a.halfAxes,t.halfAxes)},u.prototype.clone=function(a){return u.clone(this,a)},u.prototype.equals=function(a){return u.equals(this,a)},a.OrientedBoundingBox=u}));
