/**
 * @license
 * Cesium - https://github.com/CesiumGS/cesium
 * Version 1.96
 *
 * Copyright 2011-2022 Cesium Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Columbus View (Pat. Pend.)
 *
 * Portions licensed separately.
 * See https://github.com/CesiumGS/cesium/blob/main/LICENSE.md for full licensing details.
 */
define(["./AxisAlignedBoundingBox-321a482b","./Transforms-99c89742","./Matrix4-d3db9505","./defined-b681f02d","./Rectangle-0610a1c7","./TerrainEncoding-a8569660","./Math-5b6faca9","./OrientedBoundingBox-4ee28786","./RuntimeError-14317824","./WebMercatorProjection-05e4c9ff","./createTaskProcessorWorker","./Check-436535f3","./Interval-49d6e8fc","./_commonjsHelpers-a32ac251","./combine-8b9ba6cb","./RequestType-e53aab71","./AttributeCompression-055d015a","./ComponentDatatype-46a1cf7a","./WebGLConstants-f100e3dd","./Matrix2-7384588e","./TerrainQuantization-3ae29896","./EllipsoidTangentPlane-34e5c0ac","./IntersectionTests-3ac7f0c9","./Plane-172c23d7"],(function(t,e,n,i,o,a,r,s,c,u,h,l,d,g,m,p,f,I,T,E,C,M,x,N){"use strict";const b=Uint16Array.BYTES_PER_ELEMENT,S=Int32Array.BYTES_PER_ELEMENT,w=Uint32Array.BYTES_PER_ELEMENT,B=Float32Array.BYTES_PER_ELEMENT,P=Float64Array.BYTES_PER_ELEMENT;function R(t,e,n){n=i.defaultValue(n,r.CesiumMath);const o=t.length;for(let i=0;i<o;++i)if(n.equalsEpsilon(t[i],e,r.CesiumMath.EPSILON12))return i;return-1}const A=new n.Cartographic,y=new n.Cartesian3,_=new n.Cartesian3,v=new n.Cartesian3,W=new n.Matrix4;function F(t,e,o,a,s,c,u,h,l,d,g){const m=h.length;for(let p=0;p<m;++p){const f=h[p],I=f.cartographic,T=f.index,E=t.length,C=I.longitude;let M=I.latitude;M=r.CesiumMath.clamp(M,-r.CesiumMath.PI_OVER_TWO,r.CesiumMath.PI_OVER_TWO);const x=I.height-u.skirtHeight;u.hMin=Math.min(u.hMin,x),n.Cartographic.fromRadians(C,M,x,A),d&&(A.longitude+=l),d?p===m-1?A.latitude+=g:0===p&&(A.latitude-=g):A.latitude+=l;const N=u.ellipsoid.cartographicToCartesian(A);t.push(N),e.push(x),o.push(n.Cartesian2.clone(o[T])),a.length>0&&a.push(a[T]),s.length>0&&s.push(s[T]),n.Matrix4.multiplyByPoint(u.toENU,N,y);const b=u.minimum,S=u.maximum;n.Cartesian3.minimumByComponent(y,b,b),n.Cartesian3.maximumByComponent(y,S,S);const w=u.lastBorderPoint;if(i.defined(w)){const t=w.index;c.push(t,E-1,E,E,T,t)}u.lastBorderPoint=f}}return h((function(h,l){h.ellipsoid=o.Ellipsoid.clone(h.ellipsoid),h.rectangle=o.Rectangle.clone(h.rectangle);const d=function(h,l,d,g,m,p,f,I,T,E,C){let M,x,N,O,Y,k;i.defined(g)?(M=g.west,x=g.south,N=g.east,O=g.north,Y=g.width,k=g.height):(M=r.CesiumMath.toRadians(m.west),x=r.CesiumMath.toRadians(m.south),N=r.CesiumMath.toRadians(m.east),O=r.CesiumMath.toRadians(m.north),Y=r.CesiumMath.toRadians(g.width),k=r.CesiumMath.toRadians(g.height));let H=[],U=[];const V=1!==p,L=new DataView(h);let j=Number.POSITIVE_INFINITY,D=Number.NEGATIVE_INFINITY;const G=_;G.x=Number.POSITIVE_INFINITY,G.y=Number.POSITIVE_INFINITY,G.z=Number.POSITIVE_INFINITY;const z=v;z.x=Number.NEGATIVE_INFINITY,z.y=Number.NEGATIVE_INFINITY,z.z=Number.NEGATIVE_INFINITY;let q,Q,J=0,K=0,X=0;for(Q=0;Q<4;++Q){let t=J;q=L.getUint32(t,!0),t+=w;const e=r.CesiumMath.toRadians(180*L.getFloat64(t,!0));t+=P,-1===R(U,e)&&U.push(e);const n=r.CesiumMath.toRadians(180*L.getFloat64(t,!0));t+=P,-1===R(H,n)&&H.push(n),t+=2*P;let i=L.getInt32(t,!0);t+=S,K+=i,i=L.getInt32(t,!0),X+=3*i,J+=q+w}H=H.sort(),U=U.sort(),Y=2*(U[1]-U[0]),k=2*(H[1]-H[0]),H.push(H[0]+k),U.push(U[0]+Y),M=U[0],x=H[0],N=U[U.length-1],O=H[H.length-1],g=new o.Rectangle(M,x,N,O),l=d.cartographicToCartesian(o.Rectangle.center(g));const Z=e.Transforms.eastNorthUpToFixedFrame(l,d),$=n.Matrix4.inverseTransformation(Z,W);let tt,et;T&&(tt=u.WebMercatorProjection.geodeticLatitudeToMercatorAngle(x),et=1/(u.WebMercatorProjection.geodeticLatitudeToMercatorAngle(O)-tt));const nt=[],it=[],ot=new Array(K),at=new Array(K),rt=new Array(K),st=T?new Array(K):[],ct=V?new Array(K):[],ut=new Array(X),ht=[],lt=[],dt=[],gt=[];let mt=0,pt=0;for(J=0,Q=0;Q<4;++Q){q=L.getUint32(J,!0),J+=w;const t=J,e=r.CesiumMath.toRadians(180*L.getFloat64(J,!0));J+=P;const i=r.CesiumMath.toRadians(180*L.getFloat64(J,!0));J+=P;const o=r.CesiumMath.toRadians(180*L.getFloat64(J,!0)),a=.5*o;J+=P;const s=r.CesiumMath.toRadians(180*L.getFloat64(J,!0)),h=.5*s;J+=P;const l=L.getInt32(J,!0);J+=S;const g=L.getInt32(J,!0);J+=S,J+=S;const m=new Array(l);for(let t=0;t<l;++t){const c=e+L.getUint8(J++)*o;A.longitude=c;const l=i+L.getUint8(J++)*s;A.latitude=l;let g=L.getFloat32(J,!0);if(J+=B,0!==g&&g<C&&(g*=-Math.pow(2,E)),g*=6371010,A.height=g,-1!==R(U,c)||-1!==R(H,l)){const e=R(nt,A,n.Cartographic);if(-1!==e){m[t]=it[e];continue}nt.push(n.Cartographic.clone(A)),it.push(mt)}m[t]=mt,Math.abs(c-M)<a?ht.push({index:mt,cartographic:n.Cartographic.clone(A)}):Math.abs(c-N)<a?dt.push({index:mt,cartographic:n.Cartographic.clone(A)}):Math.abs(l-x)<h?lt.push({index:mt,cartographic:n.Cartographic.clone(A)}):Math.abs(l-O)<h&&gt.push({index:mt,cartographic:n.Cartographic.clone(A)}),j=Math.min(g,j),D=Math.max(g,D),rt[mt]=g;const p=d.cartographicToCartesian(A);if(ot[mt]=p,T&&(st[mt]=(u.WebMercatorProjection.geodeticLatitudeToMercatorAngle(l)-tt)*et),V){const t=d.geodeticSurfaceNormal(p);ct[mt]=t}n.Matrix4.multiplyByPoint($,p,y),n.Cartesian3.minimumByComponent(y,G,G),n.Cartesian3.maximumByComponent(y,z,z);let f=(c-M)/(N-M);f=r.CesiumMath.clamp(f,0,1);let I=(l-x)/(O-x);I=r.CesiumMath.clamp(I,0,1),at[mt]=new n.Cartesian2(f,I),++mt}const p=3*g;for(let t=0;t<p;++t,++pt)ut[pt]=m[L.getUint16(J,!0)],J+=b;if(q!==J-t)throw new c.RuntimeError("Invalid terrain tile.")}ot.length=mt,at.length=mt,rt.length=mt,T&&(st.length=mt);V&&(ct.length=mt);const ft=mt,It=pt,Tt={hMin:j,lastBorderPoint:void 0,skirtHeight:I,toENU:$,ellipsoid:d,minimum:G,maximum:z};ht.sort((function(t,e){return e.cartographic.latitude-t.cartographic.latitude})),lt.sort((function(t,e){return t.cartographic.longitude-e.cartographic.longitude})),dt.sort((function(t,e){return t.cartographic.latitude-e.cartographic.latitude})),gt.sort((function(t,e){return e.cartographic.longitude-t.cartographic.longitude}));const Et=1e-5;if(F(ot,rt,at,st,ct,ut,Tt,ht,-Et*Y,!0,-Et*k),F(ot,rt,at,st,ct,ut,Tt,lt,-Et*k,!1),F(ot,rt,at,st,ct,ut,Tt,dt,Et*Y,!0,Et*k),F(ot,rt,at,st,ct,ut,Tt,gt,Et*k,!1),ht.length>0&&gt.length>0){const t=ht[0].index,e=ft,n=gt[gt.length-1].index,i=ot.length-1;ut.push(n,i,e,e,t,n)}K=ot.length;const Ct=e.BoundingSphere.fromPoints(ot);let Mt;i.defined(g)&&(Mt=s.OrientedBoundingBox.fromRectangle(g,j,D,d));const xt=new a.EllipsoidalOccluder(d).computeHorizonCullingPointPossiblyUnderEllipsoid(l,ot,j),Nt=new t.AxisAlignedBoundingBox(G,z,l),bt=new a.TerrainEncoding(l,Nt,Tt.hMin,D,Z,!1,T,V,p,f),St=new Float32Array(K*bt.stride);let wt=0;for(let t=0;t<K;++t)wt=bt.encode(St,wt,ot[t],at[t],rt[t],void 0,st[t],ct[t]);const Bt=ht.map((function(t){return t.index})).reverse(),Pt=lt.map((function(t){return t.index})).reverse(),Rt=dt.map((function(t){return t.index})).reverse(),At=gt.map((function(t){return t.index})).reverse();return Pt.unshift(Rt[Rt.length-1]),Pt.push(Bt[0]),At.unshift(Bt[Bt.length-1]),At.push(Rt[0]),{vertices:St,indices:new Uint16Array(ut),maximumHeight:D,minimumHeight:j,encoding:bt,boundingSphere3D:Ct,orientedBoundingBox:Mt,occludeePointInScaledSpace:xt,vertexCountWithoutSkirts:ft,indexCountWithoutSkirts:It,westIndicesSouthToNorth:Bt,southIndicesEastToWest:Pt,eastIndicesNorthToSouth:Rt,northIndicesWestToEast:At}}(h.buffer,h.relativeToCenter,h.ellipsoid,h.rectangle,h.nativeRectangle,h.exaggeration,h.exaggerationRelativeHeight,h.skirtHeight,h.includeWebMercatorT,h.negativeAltitudeExponentBias,h.negativeElevationThreshold),g=d.vertices;l.push(g.buffer);const m=d.indices;return l.push(m.buffer),{vertices:g.buffer,indices:m.buffer,numberOfAttributes:d.encoding.stride,minimumHeight:d.minimumHeight,maximumHeight:d.maximumHeight,boundingSphere3D:d.boundingSphere3D,orientedBoundingBox:d.orientedBoundingBox,occludeePointInScaledSpace:d.occludeePointInScaledSpace,encoding:d.encoding,vertexCountWithoutSkirts:d.vertexCountWithoutSkirts,indexCountWithoutSkirts:d.indexCountWithoutSkirts,westIndicesSouthToNorth:d.westIndicesSouthToNorth,southIndicesEastToWest:d.southIndicesEastToWest,eastIndicesNorthToSouth:d.eastIndicesNorthToSouth,northIndicesWestToEast:d.northIndicesWestToEast}}))}));
