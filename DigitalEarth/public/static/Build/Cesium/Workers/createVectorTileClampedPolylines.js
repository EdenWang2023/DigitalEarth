/**
 * @license
 * Cesium - https://github.com/CesiumGS/cesium
 * Version 1.96
 *
 * Copyright 2011-2022 Cesium Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Columbus View (Pat. Pend.)
 *
 * Portions licensed separately.
 * See https://github.com/CesiumGS/cesium/blob/main/LICENSE.md for full licensing details.
 */
define(["./AttributeCompression-055d015a","./Matrix4-d3db9505","./combine-8b9ba6cb","./Rectangle-0610a1c7","./IndexDatatype-1b44a4e6","./Math-5b6faca9","./createTaskProcessorWorker","./ComponentDatatype-46a1cf7a","./defined-b681f02d","./Check-436535f3","./WebGLConstants-f100e3dd","./Matrix2-7384588e","./RuntimeError-14317824"],(function(t,e,a,s,n,r,i,o,c,d,l,f,h){"use strict";const u=32767,C=Math.cos(r.CesiumMath.toRadians(150)),p=new e.Cartographic,b=new e.Cartesian3;const m=new e.Cartographic,A=new e.Cartographic;function w(t){const e=8*t,a=3*e,s=4*e;this.startEllipsoidNormals=new Float32Array(a),this.endEllipsoidNormals=new Float32Array(a),this.startPositionAndHeights=new Float32Array(s),this.startFaceNormalAndVertexCornerIds=new Float32Array(s),this.endPositionAndHeights=new Float32Array(s),this.endFaceNormalAndHalfWidths=new Float32Array(s),this.vertexBatchIds=new Uint16Array(e),this.indices=n.IndexDatatype.createTypedArray(e,36*t),this.vec3Offset=0,this.vec4Offset=0,this.batchIdOffset=0,this.indexOffset=0,this.volumeStartIndex=0}const g=new e.Cartesian3,y=new e.Cartesian3;function N(t,a,s,n,r){const i=e.Cartesian3.subtract(s,a,y);let o=e.Cartesian3.subtract(a,t,g);return e.Cartesian3.normalize(i,i),e.Cartesian3.normalize(o,o),e.Cartesian3.dot(i,o)<C&&(o=e.Cartesian3.multiplyByScalar(o,-1,g)),e.Cartesian3.add(i,o,r),e.Cartesian3.equals(r,e.Cartesian3.ZERO)&&(r=e.Cartesian3.subtract(t,a)),e.Cartesian3.cross(r,n,r),e.Cartesian3.cross(n,r,r),e.Cartesian3.normalize(r,r),r}const k=[0,2,6,0,6,4,0,1,3,0,3,2,0,4,5,0,5,1,5,3,1,5,7,3,7,5,4,7,4,6,7,6,2,7,2,3],x=k.length,I=new e.Cartesian3,E=new e.Cartesian3,F=new e.Cartesian3,H=new e.Cartesian3,O=new e.Cartesian3;w.prototype.addVolume=function(t,a,s,n,r,i,o,c,d,l){let f=e.Cartesian3.add(a,d,I);const h=l.geodeticSurfaceNormal(f,E);f=e.Cartesian3.add(s,d,I);const u=l.geodeticSurfaceNormal(f,H),C=N(t,a,s,h,F),p=N(n,s,a,u,O),b=this.startEllipsoidNormals,m=this.endEllipsoidNormals,A=this.startPositionAndHeights,w=this.startFaceNormalAndVertexCornerIds,g=this.endPositionAndHeights,y=this.endFaceNormalAndHalfWidths,P=this.vertexBatchIds;let v,D=this.batchIdOffset,M=this.vec3Offset,R=this.vec4Offset;for(v=0;v<8;v++)e.Cartesian3.pack(h,b,M),e.Cartesian3.pack(u,m,M),e.Cartesian3.pack(a,A,R),A[R+3]=r,e.Cartesian3.pack(s,g,R),g[R+3]=i,e.Cartesian3.pack(C,w,R),w[R+3]=v,e.Cartesian3.pack(p,y,R),y[R+3]=o,P[D++]=c,M+=3,R+=4;this.batchIdOffset=D,this.vec3Offset=M,this.vec4Offset=R;const S=this.indices,U=this.volumeStartIndex,B=this.indexOffset;for(v=0;v<x;v++)S[B+v]=k[v]+U;this.volumeStartIndex+=8,this.indexOffset+=x};const P=new s.Rectangle,v=new s.Ellipsoid,D=new e.Cartesian3,M=new e.Cartesian3,R=new e.Cartesian3,S=new e.Cartesian3,U=new e.Cartesian3;return i((function(i,o){const c=new Uint16Array(i.positions),d=new Uint16Array(i.widths),l=new Uint32Array(i.counts),f=new Uint16Array(i.batchIds),h=P,C=v,g=D,y=new Float64Array(i.packedBuffer);let N=0;const k=y[N++],x=y[N++];let I;s.Rectangle.unpack(y,N,h),N+=s.Rectangle.packedLength,s.Ellipsoid.unpack(y,N,C),N+=s.Ellipsoid.packedLength,e.Cartesian3.unpack(y,N,g);let E=c.length/3;const F=c.subarray(0,E),H=c.subarray(E,2*E),O=c.subarray(2*E,3*E);t.AttributeCompression.zigZagDeltaDecode(F,H,O),function(t,a,s,n){const r=n.length,i=t.length,o=new Uint8Array(i),c=m,d=A;let l=0;for(let s=0;s<r;s++){const r=n[s];let i=r;for(let s=1;s<r;s++){const n=l+s,r=n-1;d.longitude=t[n],d.latitude=a[n],c.longitude=t[r],c.latitude=a[r],e.Cartographic.equals(d,c)&&(i--,o[r]=1)}n[s]=i,l+=r}let f=0;for(let e=0;e<i;e++)1!==o[e]&&(t[f]=t[e],a[f]=a[e],s[f]=s[e],f++)}(F,H,O,l);const B=l.length;let T=0;for(I=0;I<B;I++){T+=l[I]-1}const V=new w(T),W=function(t,a,s,n,i,o,c){const d=t.length,l=new Float64Array(3*d);for(let f=0;f<d;++f){const d=t[f],h=a[f],C=s[f],m=r.CesiumMath.lerp(n.west,n.east,d/u),A=r.CesiumMath.lerp(n.south,n.north,h/u),w=r.CesiumMath.lerp(i,o,C/u),g=e.Cartographic.fromRadians(m,A,w,p),y=c.cartographicToCartesian(g,b);e.Cartesian3.pack(y,l,3*f)}return l}(F,H,O,h,k,x,C);E=F.length;const z=new Float32Array(3*E);for(I=0;I<E;++I)z[3*I]=W[3*I]-g.x,z[3*I+1]=W[3*I+1]-g.y,z[3*I+2]=W[3*I+2]-g.z;let q=0,L=0;for(I=0;I<B;I++){const t=l[I]-1,a=.5*d[I],s=f[I],n=q;for(let i=0;i<t;i++){const o=e.Cartesian3.unpack(z,q,R),c=e.Cartesian3.unpack(z,q+3,S);let d=O[L],l=O[L+1];d=r.CesiumMath.lerp(k,x,d/u),l=r.CesiumMath.lerp(k,x,l/u),L++;let f=M,h=U;if(0===i){const a=n+3*t,s=e.Cartesian3.unpack(z,a,M);if(e.Cartesian3.equals(s,o))e.Cartesian3.unpack(z,a-3,f);else{const t=e.Cartesian3.subtract(o,c,M);f=e.Cartesian3.add(t,o,M)}}else e.Cartesian3.unpack(z,q-3,f);if(i===t-1){const t=e.Cartesian3.unpack(z,n,U);if(e.Cartesian3.equals(t,c))e.Cartesian3.unpack(z,n+3,h);else{const t=e.Cartesian3.subtract(c,o,U);h=e.Cartesian3.add(t,c,U)}}else e.Cartesian3.unpack(z,q+6,h);V.addVolume(f,o,c,h,d,l,a,s,g,C),q+=3}q+=3,L++}const _=V.indices;o.push(V.startEllipsoidNormals.buffer),o.push(V.endEllipsoidNormals.buffer),o.push(V.startPositionAndHeights.buffer),o.push(V.startFaceNormalAndVertexCornerIds.buffer),o.push(V.endPositionAndHeights.buffer),o.push(V.endFaceNormalAndHalfWidths.buffer),o.push(V.vertexBatchIds.buffer),o.push(_.buffer);let G={indexDatatype:2===_.BYTES_PER_ELEMENT?n.IndexDatatype.UNSIGNED_SHORT:n.IndexDatatype.UNSIGNED_INT,startEllipsoidNormals:V.startEllipsoidNormals.buffer,endEllipsoidNormals:V.endEllipsoidNormals.buffer,startPositionAndHeights:V.startPositionAndHeights.buffer,startFaceNormalAndVertexCornerIds:V.startFaceNormalAndVertexCornerIds.buffer,endPositionAndHeights:V.endPositionAndHeights.buffer,endFaceNormalAndHalfWidths:V.endFaceNormalAndHalfWidths.buffer,vertexBatchIds:V.vertexBatchIds.buffer,indices:_.buffer};if(i.keepDecodedPositions){const t=function(t){const e=t.length,a=new Uint32Array(e+1);let s=0;for(let n=0;n<e;++n)a[n]=s,s+=t[n];return a[e]=s,a}(l);o.push(W.buffer,t.buffer),G=a.combine(G,{decodedPositions:W.buffer,decodedPositionOffsets:t.buffer})}return G}))}));
