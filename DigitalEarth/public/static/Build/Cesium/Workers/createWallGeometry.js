/**
 * @license
 * Cesium - https://github.com/CesiumGS/cesium
 * Version 1.96
 *
 * Copyright 2011-2022 Cesium Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Columbus View (Pat. Pend.)
 *
 * Portions licensed separately.
 * See https://github.com/CesiumGS/cesium/blob/main/LICENSE.md for full licensing details.
 */
define(["./defined-b681f02d","./Rectangle-0610a1c7","./Transforms-99c89742","./Matrix4-d3db9505","./ComponentDatatype-46a1cf7a","./Check-436535f3","./GeometryAttribute-ef6ca9ab","./GeometryAttributes-18ccc0d6","./IndexDatatype-1b44a4e6","./Math-5b6faca9","./VertexFormat-1359575c","./WallGeometryLibrary-e12447a2","./Interval-49d6e8fc","./_commonjsHelpers-a32ac251","./combine-8b9ba6cb","./RequestType-e53aab71","./RuntimeError-14317824","./WebGLConstants-f100e3dd","./Matrix2-7384588e","./arrayRemoveDuplicates-bbac3e0e","./PolylinePipeline-c42c443b","./EllipsoidGeodesic-bd79a412","./EllipsoidRhumbLine-65d4aeca","./IntersectionTests-3ac7f0c9","./Plane-172c23d7"],(function(e,t,n,i,a,o,r,s,l,m,c,u,p,d,y,f,g,h,C,b,x,A,_,E,v){"use strict";const w=new i.Cartesian3,F=new i.Cartesian3,L=new i.Cartesian3,k=new i.Cartesian3,H=new i.Cartesian3,V=new i.Cartesian3,G=new i.Cartesian3;function D(n){const a=(n=e.defaultValue(n,e.defaultValue.EMPTY_OBJECT)).positions,o=n.maximumHeights,r=n.minimumHeights,s=e.defaultValue(n.vertexFormat,c.VertexFormat.DEFAULT),l=e.defaultValue(n.granularity,m.CesiumMath.RADIANS_PER_DEGREE),u=e.defaultValue(n.ellipsoid,t.Ellipsoid.WGS84);this._positions=a,this._minimumHeights=r,this._maximumHeights=o,this._vertexFormat=c.VertexFormat.clone(s),this._granularity=l,this._ellipsoid=t.Ellipsoid.clone(u),this._workerName="createWallGeometry";let p=1+a.length*i.Cartesian3.packedLength+2;e.defined(r)&&(p+=r.length),e.defined(o)&&(p+=o.length),this.packedLength=p+t.Ellipsoid.packedLength+c.VertexFormat.packedLength+1}D.pack=function(n,a,o){let r;o=e.defaultValue(o,0);const s=n._positions;let l=s.length;for(a[o++]=l,r=0;r<l;++r,o+=i.Cartesian3.packedLength)i.Cartesian3.pack(s[r],a,o);const m=n._minimumHeights;if(l=e.defined(m)?m.length:0,a[o++]=l,e.defined(m))for(r=0;r<l;++r)a[o++]=m[r];const u=n._maximumHeights;if(l=e.defined(u)?u.length:0,a[o++]=l,e.defined(u))for(r=0;r<l;++r)a[o++]=u[r];return t.Ellipsoid.pack(n._ellipsoid,a,o),o+=t.Ellipsoid.packedLength,c.VertexFormat.pack(n._vertexFormat,a,o),a[o+=c.VertexFormat.packedLength]=n._granularity,a};const P=t.Ellipsoid.clone(t.Ellipsoid.UNIT_SPHERE),T=new c.VertexFormat,z={positions:void 0,minimumHeights:void 0,maximumHeights:void 0,ellipsoid:P,vertexFormat:T,granularity:void 0};return D.unpack=function(n,a,o){let r;a=e.defaultValue(a,0);let s=n[a++];const l=new Array(s);for(r=0;r<s;++r,a+=i.Cartesian3.packedLength)l[r]=i.Cartesian3.unpack(n,a);let m,u;if(s=n[a++],s>0)for(m=new Array(s),r=0;r<s;++r)m[r]=n[a++];if(s=n[a++],s>0)for(u=new Array(s),r=0;r<s;++r)u[r]=n[a++];const p=t.Ellipsoid.unpack(n,a,P);a+=t.Ellipsoid.packedLength;const d=c.VertexFormat.unpack(n,a,T),y=n[a+=c.VertexFormat.packedLength];return e.defined(o)?(o._positions=l,o._minimumHeights=m,o._maximumHeights=u,o._ellipsoid=t.Ellipsoid.clone(p,o._ellipsoid),o._vertexFormat=c.VertexFormat.clone(d,o._vertexFormat),o._granularity=y,o):(z.positions=l,z.minimumHeights=m,z.maximumHeights=u,z.granularity=y,new D(z))},D.fromConstantHeights=function(t){const n=(t=e.defaultValue(t,e.defaultValue.EMPTY_OBJECT)).positions;let i,a;const o=t.minimumHeight,r=t.maximumHeight,s=e.defined(o),l=e.defined(r);if(s||l){const e=n.length;i=s?new Array(e):void 0,a=l?new Array(e):void 0;for(let t=0;t<e;++t)s&&(i[t]=o),l&&(a[t]=r)}return new D({positions:n,maximumHeights:a,minimumHeights:i,ellipsoid:t.ellipsoid,vertexFormat:t.vertexFormat})},D.createGeometry=function(t){const o=t._positions,c=t._minimumHeights,p=t._maximumHeights,d=t._vertexFormat,y=t._granularity,f=t._ellipsoid,g=u.WallGeometryLibrary.computePositions(f,o,p,c,y,!0);if(!e.defined(g))return;const h=g.bottomPositions,C=g.topPositions,b=g.numCorners;let x=C.length,A=2*x;const _=d.position?new Float64Array(A):void 0,E=d.normal?new Float32Array(A):void 0,v=d.tangent?new Float32Array(A):void 0,D=d.bitangent?new Float32Array(A):void 0,P=d.st?new Float32Array(A/3*2):void 0;let T,z=0,R=0,O=0,I=0,S=0,M=G,N=V,W=H,B=!0;x/=3;let q=0;const U=1/(x-b-1);for(T=0;T<x;++T){const e=3*T,t=i.Cartesian3.fromArray(C,e,w),n=i.Cartesian3.fromArray(h,e,F);if(d.position&&(_[z++]=n.x,_[z++]=n.y,_[z++]=n.z,_[z++]=t.x,_[z++]=t.y,_[z++]=t.z),d.st&&(P[S++]=q,P[S++]=0,P[S++]=q,P[S++]=1),d.normal||d.tangent||d.bitangent){let n=i.Cartesian3.clone(i.Cartesian3.ZERO,k);const a=i.Cartesian3.subtract(t,f.geodeticSurfaceNormal(t,F),F);if(T+1<x&&(n=i.Cartesian3.fromArray(C,e+3,k)),B){const e=i.Cartesian3.subtract(n,t,L),o=i.Cartesian3.subtract(a,t,w);M=i.Cartesian3.normalize(i.Cartesian3.cross(o,e,M),M),B=!1}i.Cartesian3.equalsEpsilon(t,n,m.CesiumMath.EPSILON10)?B=!0:(q+=U,d.tangent&&(N=i.Cartesian3.normalize(i.Cartesian3.subtract(n,t,N),N)),d.bitangent&&(W=i.Cartesian3.normalize(i.Cartesian3.cross(M,N,W),W))),d.normal&&(E[R++]=M.x,E[R++]=M.y,E[R++]=M.z,E[R++]=M.x,E[R++]=M.y,E[R++]=M.z),d.tangent&&(v[I++]=N.x,v[I++]=N.y,v[I++]=N.z,v[I++]=N.x,v[I++]=N.y,v[I++]=N.z),d.bitangent&&(D[O++]=W.x,D[O++]=W.y,D[O++]=W.z,D[O++]=W.x,D[O++]=W.y,D[O++]=W.z)}}const J=new s.GeometryAttributes;d.position&&(J.position=new r.GeometryAttribute({componentDatatype:a.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:_})),d.normal&&(J.normal=new r.GeometryAttribute({componentDatatype:a.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:E})),d.tangent&&(J.tangent=new r.GeometryAttribute({componentDatatype:a.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:v})),d.bitangent&&(J.bitangent=new r.GeometryAttribute({componentDatatype:a.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:D})),d.st&&(J.st=new r.GeometryAttribute({componentDatatype:a.ComponentDatatype.FLOAT,componentsPerAttribute:2,values:P}));const Y=A/3;A-=6*(b+1);const j=l.IndexDatatype.createTypedArray(Y,A);let Z=0;for(T=0;T<Y-2;T+=2){const e=T,t=T+2,n=i.Cartesian3.fromArray(_,3*e,w),a=i.Cartesian3.fromArray(_,3*t,F);if(i.Cartesian3.equalsEpsilon(n,a,m.CesiumMath.EPSILON10))continue;const o=T+1,r=T+3;j[Z++]=o,j[Z++]=e,j[Z++]=r,j[Z++]=r,j[Z++]=e,j[Z++]=t}return new r.Geometry({attributes:J,indices:j,primitiveType:r.PrimitiveType.TRIANGLES,boundingSphere:new n.BoundingSphere.fromVertices(_)})},function(n,i){return e.defined(i)&&(n=D.unpack(n,i)),n._ellipsoid=t.Ellipsoid.clone(n._ellipsoid),D.createGeometry(n)}}));
