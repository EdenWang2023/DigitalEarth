/**
 * @license
 * Cesium - https://github.com/CesiumGS/cesium
 * Version 1.96
 *
 * Copyright 2011-2022 Cesium Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Columbus View (Pat. Pend.)
 *
 * Portions licensed separately.
 * See https://github.com/CesiumGS/cesium/blob/main/LICENSE.md for full licensing details.
 */
define(["./defined-b681f02d","./Rectangle-0610a1c7","./ArcType-f5af12f9","./arrayRemoveDuplicates-bbac3e0e","./Transforms-99c89742","./Matrix4-d3db9505","./Color-151cb095","./ComponentDatatype-46a1cf7a","./Check-436535f3","./GeometryAttribute-ef6ca9ab","./GeometryAttributes-18ccc0d6","./IndexDatatype-1b44a4e6","./Math-5b6faca9","./PolylinePipeline-c42c443b","./VertexFormat-1359575c","./Interval-49d6e8fc","./_commonjsHelpers-a32ac251","./combine-8b9ba6cb","./RequestType-e53aab71","./RuntimeError-14317824","./WebGLConstants-f100e3dd","./Matrix2-7384588e","./EllipsoidGeodesic-bd79a412","./EllipsoidRhumbLine-65d4aeca","./IntersectionTests-3ac7f0c9","./Plane-172c23d7"],(function(e,t,o,n,r,a,i,l,s,c,p,d,u,y,m,f,h,C,g,b,_,A,E,P,x,T){"use strict";const w=[];function k(e,t,o,n,r){const a=w;let l;a.length=r;const s=o.red,c=o.green,p=o.blue,d=o.alpha,u=n.red,y=n.green,m=n.blue,f=n.alpha;if(i.Color.equals(o,n)){for(l=0;l<r;l++)a[l]=i.Color.clone(o);return a}const h=(u-s)/r,C=(y-c)/r,g=(m-p)/r,b=(f-d)/r;for(l=0;l<r;l++)a[l]=new i.Color(s+l*h,c+l*C,p+l*g,d+l*b);return a}function D(n){const r=(n=e.defaultValue(n,e.defaultValue.EMPTY_OBJECT)).positions,l=n.colors,s=e.defaultValue(n.width,1),c=e.defaultValue(n.colorsPerVertex,!1);this._positions=r,this._colors=l,this._width=s,this._colorsPerVertex=c,this._vertexFormat=m.VertexFormat.clone(e.defaultValue(n.vertexFormat,m.VertexFormat.DEFAULT)),this._arcType=e.defaultValue(n.arcType,o.ArcType.GEODESIC),this._granularity=e.defaultValue(n.granularity,u.CesiumMath.RADIANS_PER_DEGREE),this._ellipsoid=t.Ellipsoid.clone(e.defaultValue(n.ellipsoid,t.Ellipsoid.WGS84)),this._workerName="createPolylineGeometry";let p=1+r.length*a.Cartesian3.packedLength;p+=e.defined(l)?1+l.length*i.Color.packedLength:1,this.packedLength=p+t.Ellipsoid.packedLength+m.VertexFormat.packedLength+4}D.pack=function(o,n,r){let l;r=e.defaultValue(r,0);const s=o._positions;let c=s.length;for(n[r++]=c,l=0;l<c;++l,r+=a.Cartesian3.packedLength)a.Cartesian3.pack(s[l],n,r);const p=o._colors;for(c=e.defined(p)?p.length:0,n[r++]=c,l=0;l<c;++l,r+=i.Color.packedLength)i.Color.pack(p[l],n,r);return t.Ellipsoid.pack(o._ellipsoid,n,r),r+=t.Ellipsoid.packedLength,m.VertexFormat.pack(o._vertexFormat,n,r),r+=m.VertexFormat.packedLength,n[r++]=o._width,n[r++]=o._colorsPerVertex?1:0,n[r++]=o._arcType,n[r]=o._granularity,n};const v=t.Ellipsoid.clone(t.Ellipsoid.UNIT_SPHERE),V=new m.VertexFormat,L={positions:void 0,colors:void 0,ellipsoid:v,vertexFormat:V,width:void 0,colorsPerVertex:void 0,arcType:void 0,granularity:void 0};D.unpack=function(o,n,r){let l;n=e.defaultValue(n,0);let s=o[n++];const c=new Array(s);for(l=0;l<s;++l,n+=a.Cartesian3.packedLength)c[l]=a.Cartesian3.unpack(o,n);s=o[n++];const p=s>0?new Array(s):void 0;for(l=0;l<s;++l,n+=i.Color.packedLength)p[l]=i.Color.unpack(o,n);const d=t.Ellipsoid.unpack(o,n,v);n+=t.Ellipsoid.packedLength;const u=m.VertexFormat.unpack(o,n,V);n+=m.VertexFormat.packedLength;const y=o[n++],f=1===o[n++],h=o[n++],C=o[n];return e.defined(r)?(r._positions=c,r._colors=p,r._ellipsoid=t.Ellipsoid.clone(d,r._ellipsoid),r._vertexFormat=m.VertexFormat.clone(u,r._vertexFormat),r._width=y,r._colorsPerVertex=f,r._arcType=h,r._granularity=C,r):(L.positions=c,L.colors=p,L.width=y,L.colorsPerVertex=f,L.arcType=h,L.granularity=C,new D(L))};const F=new a.Cartesian3,G=new a.Cartesian3,R=new a.Cartesian3,I=new a.Cartesian3;return D.createGeometry=function(t){const s=t._width,m=t._vertexFormat;let f=t._colors;const h=t._colorsPerVertex,C=t._arcType,g=t._granularity,b=t._ellipsoid;let _,A,E;const P=[];let x=n.arrayRemoveDuplicates(t._positions,a.Cartesian3.equalsEpsilon,!1,P);if(e.defined(f)&&P.length>0){let e=0,t=P[0];f=f.filter((function(o,n){let r=!1;return r=h?n===t||0===n&&1===t:n+1===t,!r||(e++,t=P[e],!1)}))}let T=x.length;if(T<2||s<=0)return;if(C===o.ArcType.GEODESIC||C===o.ArcType.RHUMB){let t,n;C===o.ArcType.GEODESIC?(t=u.CesiumMath.chordLength(g,b.maximumRadius),n=y.PolylinePipeline.numberOfPoints):(t=g,n=y.PolylinePipeline.numberOfPointsRhumbLine);const r=y.PolylinePipeline.extractHeights(x,b);if(e.defined(f)){let e=1;for(_=0;_<T-1;++_)e+=n(x[_],x[_+1],t);const o=new Array(e);let r=0;for(_=0;_<T-1;++_){const a=x[_],l=x[_+1],s=f[_],c=n(a,l,t);if(h&&_<e){const e=k(0,0,s,f[_+1],c),t=e.length;for(A=0;A<t;++A)o[r++]=e[A]}else for(A=0;A<c;++A)o[r++]=i.Color.clone(s)}o[r]=i.Color.clone(f[f.length-1]),f=o,w.length=0}x=C===o.ArcType.GEODESIC?y.PolylinePipeline.generateCartesianArc({positions:x,minDistance:t,ellipsoid:b,height:r}):y.PolylinePipeline.generateCartesianRhumbArc({positions:x,granularity:t,ellipsoid:b,height:r})}T=x.length;const D=4*T-4,v=new Float64Array(3*D),V=new Float64Array(3*D),L=new Float64Array(3*D),O=new Float32Array(2*D),S=m.st?new Float32Array(2*D):void 0,B=e.defined(f)?new Uint8Array(4*D):void 0;let M,U=0,N=0,H=0,q=0;for(A=0;A<T;++A){let t,o;0===A?(M=F,a.Cartesian3.subtract(x[0],x[1],M),a.Cartesian3.add(x[0],M,M)):M=x[A-1],a.Cartesian3.clone(M,R),a.Cartesian3.clone(x[A],G),A===T-1?(M=F,a.Cartesian3.subtract(x[T-1],x[T-2],M),a.Cartesian3.add(x[T-1],M,M)):M=x[A+1],a.Cartesian3.clone(M,I),e.defined(B)&&(t=0===A||h?f[A]:f[A-1],A!==T-1&&(o=f[A]));const n=A===T-1?2:4;for(E=0===A?2:0;E<n;++E){a.Cartesian3.pack(G,v,U),a.Cartesian3.pack(R,V,U),a.Cartesian3.pack(I,L,U),U+=3;const n=E-2<0?-1:1;if(O[N++]=E%2*2-1,O[N++]=n*s,m.st&&(S[H++]=A/(T-1),S[H++]=Math.max(O[N-2],0)),e.defined(B)){const e=E<2?t:o;B[q++]=i.Color.floatToByte(e.red),B[q++]=i.Color.floatToByte(e.green),B[q++]=i.Color.floatToByte(e.blue),B[q++]=i.Color.floatToByte(e.alpha)}}}const W=new p.GeometryAttributes;W.position=new c.GeometryAttribute({componentDatatype:l.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:v}),W.prevPosition=new c.GeometryAttribute({componentDatatype:l.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:V}),W.nextPosition=new c.GeometryAttribute({componentDatatype:l.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:L}),W.expandAndWidth=new c.GeometryAttribute({componentDatatype:l.ComponentDatatype.FLOAT,componentsPerAttribute:2,values:O}),m.st&&(W.st=new c.GeometryAttribute({componentDatatype:l.ComponentDatatype.FLOAT,componentsPerAttribute:2,values:S})),e.defined(B)&&(W.color=new c.GeometryAttribute({componentDatatype:l.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:4,values:B,normalize:!0}));const Y=d.IndexDatatype.createTypedArray(D,6*T-6);let j=0,z=0;const J=T-1;for(A=0;A<J;++A)Y[z++]=j,Y[z++]=j+2,Y[z++]=j+1,Y[z++]=j+1,Y[z++]=j+2,Y[z++]=j+3,j+=4;return new c.Geometry({attributes:W,indices:Y,primitiveType:c.PrimitiveType.TRIANGLES,boundingSphere:r.BoundingSphere.fromPoints(x),geometryType:c.GeometryType.POLYLINES})},function(o,n){return e.defined(n)&&(o=D.unpack(o,n)),o._ellipsoid=t.Ellipsoid.clone(o._ellipsoid),D.createGeometry(o)}}));
