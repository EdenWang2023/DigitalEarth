/**
 * @license
 * Cesium - https://github.com/CesiumGS/cesium
 * Version 1.96
 *
 * Copyright 2011-2022 Cesium Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Columbus View (Pat. Pend.)
 *
 * Portions licensed separately.
 * See https://github.com/CesiumGS/cesium/blob/main/LICENSE.md for full licensing details.
 */
define(["exports","./Transforms-99c89742","./Matrix4-d3db9505","./ComponentDatatype-46a1cf7a","./CylinderGeometryLibrary-2359532f","./defined-b681f02d","./Check-436535f3","./GeometryAttribute-ef6ca9ab","./GeometryAttributes-18ccc0d6","./GeometryOffsetAttribute-3e5f3e97","./IndexDatatype-1b44a4e6","./Math-5b6faca9","./VertexFormat-1359575c"],(function(t,e,n,a,o,r,i,s,m,u,c,l,f){"use strict";const d=new n.Cartesian2,p=new n.Cartesian3,y=new n.Cartesian3,b=new n.Cartesian3,A=new n.Cartesian3;function x(t){const e=(t=r.defaultValue(t,r.defaultValue.EMPTY_OBJECT)).length,n=t.topRadius,a=t.bottomRadius,o=r.defaultValue(t.vertexFormat,f.VertexFormat.DEFAULT),i=r.defaultValue(t.slices,128);this._length=e,this._topRadius=n,this._bottomRadius=a,this._vertexFormat=f.VertexFormat.clone(o),this._slices=i,this._offsetAttribute=t.offsetAttribute,this._workerName="createCylinderGeometry"}x.packedLength=f.VertexFormat.packedLength+5,x.pack=function(t,e,n){return n=r.defaultValue(n,0),f.VertexFormat.pack(t._vertexFormat,e,n),n+=f.VertexFormat.packedLength,e[n++]=t._length,e[n++]=t._topRadius,e[n++]=t._bottomRadius,e[n++]=t._slices,e[n]=r.defaultValue(t._offsetAttribute,-1),e};const g=new f.VertexFormat,_={vertexFormat:g,length:void 0,topRadius:void 0,bottomRadius:void 0,slices:void 0,offsetAttribute:void 0};let h;x.unpack=function(t,e,n){e=r.defaultValue(e,0);const a=f.VertexFormat.unpack(t,e,g);e+=f.VertexFormat.packedLength;const o=t[e++],i=t[e++],s=t[e++],m=t[e++],u=t[e];return r.defined(n)?(n._vertexFormat=f.VertexFormat.clone(a,n._vertexFormat),n._length=o,n._topRadius=i,n._bottomRadius=s,n._slices=m,n._offsetAttribute=-1===u?void 0:u,n):(_.length=o,_.topRadius=i,_.bottomRadius=s,_.slices=m,_.offsetAttribute=-1===u?void 0:u,new x(_))},x.createGeometry=function(t){let i=t._length;const f=t._topRadius,x=t._bottomRadius,g=t._vertexFormat,_=t._slices;if(i<=0||f<0||x<0||0===f&&0===x)return;const h=_+_,C=_+h,F=h+h,v=o.CylinderGeometryLibrary.computePositions(i,f,x,_,!0),w=g.st?new Float32Array(2*F):void 0,G=g.normal?new Float32Array(3*F):void 0,D=g.tangent?new Float32Array(3*F):void 0,R=g.bitangent?new Float32Array(3*F):void 0;let V;const T=g.normal||g.tangent||g.bitangent;if(T){const t=g.tangent||g.bitangent;let e=0,a=0,o=0;const r=Math.atan2(x-f,i),s=p;s.z=Math.sin(r);const m=Math.cos(r);let u=b,c=y;for(V=0;V<_;V++){const r=V/_*l.CesiumMath.TWO_PI,i=m*Math.cos(r),f=m*Math.sin(r);T&&(s.x=i,s.y=f,t&&(u=n.Cartesian3.normalize(n.Cartesian3.cross(n.Cartesian3.UNIT_Z,s,u),u)),g.normal&&(G[e++]=s.x,G[e++]=s.y,G[e++]=s.z,G[e++]=s.x,G[e++]=s.y,G[e++]=s.z),g.tangent&&(D[a++]=u.x,D[a++]=u.y,D[a++]=u.z,D[a++]=u.x,D[a++]=u.y,D[a++]=u.z),g.bitangent&&(c=n.Cartesian3.normalize(n.Cartesian3.cross(s,u,c),c),R[o++]=c.x,R[o++]=c.y,R[o++]=c.z,R[o++]=c.x,R[o++]=c.y,R[o++]=c.z))}for(V=0;V<_;V++)g.normal&&(G[e++]=0,G[e++]=0,G[e++]=-1),g.tangent&&(D[a++]=1,D[a++]=0,D[a++]=0),g.bitangent&&(R[o++]=0,R[o++]=-1,R[o++]=0);for(V=0;V<_;V++)g.normal&&(G[e++]=0,G[e++]=0,G[e++]=1),g.tangent&&(D[a++]=1,D[a++]=0,D[a++]=0),g.bitangent&&(R[o++]=0,R[o++]=1,R[o++]=0)}const O=12*_-12,L=c.IndexDatatype.createTypedArray(F,O);let M=0,P=0;for(V=0;V<_-1;V++)L[M++]=P,L[M++]=P+2,L[M++]=P+3,L[M++]=P,L[M++]=P+3,L[M++]=P+1,P+=2;for(L[M++]=h-2,L[M++]=0,L[M++]=1,L[M++]=h-2,L[M++]=1,L[M++]=h-1,V=1;V<_-1;V++)L[M++]=h+V+1,L[M++]=h+V,L[M++]=h;for(V=1;V<_-1;V++)L[M++]=C,L[M++]=C+V,L[M++]=C+V+1;let k=0;if(g.st){const t=Math.max(f,x);for(V=0;V<F;V++){const e=n.Cartesian3.fromArray(v,3*V,A);w[k++]=(e.x+t)/(2*t),w[k++]=(e.y+t)/(2*t)}}const z=new m.GeometryAttributes;g.position&&(z.position=new s.GeometryAttribute({componentDatatype:a.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:v})),g.normal&&(z.normal=new s.GeometryAttribute({componentDatatype:a.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:G})),g.tangent&&(z.tangent=new s.GeometryAttribute({componentDatatype:a.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:D})),g.bitangent&&(z.bitangent=new s.GeometryAttribute({componentDatatype:a.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:R})),g.st&&(z.st=new s.GeometryAttribute({componentDatatype:a.ComponentDatatype.FLOAT,componentsPerAttribute:2,values:w})),d.x=.5*i,d.y=Math.max(x,f);const E=new e.BoundingSphere(n.Cartesian3.ZERO,n.Cartesian2.magnitude(d));if(r.defined(t._offsetAttribute)){i=v.length;const e=t._offsetAttribute===u.GeometryOffsetAttribute.NONE?0:1,n=new Uint8Array(i/3).fill(e);z.applyOffset=new s.GeometryAttribute({componentDatatype:a.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:n})}return new s.Geometry({attributes:z,indices:L,primitiveType:s.PrimitiveType.TRIANGLES,boundingSphere:E,offsetAttribute:t._offsetAttribute})},x.getUnitCylinder=function(){return r.defined(h)||(h=x.createGeometry(new x({topRadius:1,bottomRadius:1,length:1,vertexFormat:f.VertexFormat.POSITION_ONLY}))),h},t.CylinderGeometry=x}));
