/**
 * @license
 * Cesium - https://github.com/CesiumGS/cesium
 * Version 1.96
 *
 * Copyright 2011-2022 Cesium Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Columbus View (Pat. Pend.)
 *
 * Portions licensed separately.
 * See https://github.com/CesiumGS/cesium/blob/main/LICENSE.md for full licensing details.
 */
define(["./AxisAlignedBoundingBox-321a482b","./Matrix4-d3db9505","./defined-b681f02d","./Rectangle-0610a1c7","./TerrainEncoding-a8569660","./IndexDatatype-1b44a4e6","./Math-5b6faca9","./Check-436535f3","./Transforms-99c89742","./WebMercatorProjection-05e4c9ff","./createTaskProcessorWorker","./RuntimeError-14317824","./AttributeCompression-055d015a","./ComponentDatatype-46a1cf7a","./WebGLConstants-f100e3dd","./Matrix2-7384588e","./TerrainQuantization-3ae29896","./Interval-49d6e8fc","./_commonjsHelpers-a32ac251","./combine-8b9ba6cb","./RequestType-e53aab71"],(function(e,t,r,n,o,i,a,s,c,d,h,u,l,I,g,m,T,f,E,p,y){"use strict";function N(){s.DeveloperError.throwInstantiationError()}Object.defineProperties(N.prototype,{errorEvent:{get:s.DeveloperError.throwInstantiationError},credit:{get:s.DeveloperError.throwInstantiationError},tilingScheme:{get:s.DeveloperError.throwInstantiationError},ready:{get:s.DeveloperError.throwInstantiationError},readyPromise:{get:s.DeveloperError.throwInstantiationError},hasWaterMask:{get:s.DeveloperError.throwInstantiationError},hasVertexNormals:{get:s.DeveloperError.throwInstantiationError},availability:{get:s.DeveloperError.throwInstantiationError}});const w=[];N.getRegularGridIndices=function(e,t){let n=w[e];r.defined(n)||(w[e]=n=[]);let o=n[t];return r.defined(o)||(o=e*t<a.CesiumMath.SIXTY_FOUR_KILOBYTES?n[t]=new Uint16Array((e-1)*(t-1)*6):n[t]=new Uint32Array((e-1)*(t-1)*6),x(e,t,o,0)),o};const b=[];N.getRegularGridIndicesAndEdgeIndices=function(e,t){let n=b[e];r.defined(n)||(b[e]=n=[]);let o=n[t];if(!r.defined(o)){const r=N.getRegularGridIndices(e,t),i=S(e,t),a=i.westIndicesSouthToNorth,s=i.southIndicesEastToWest,c=i.eastIndicesNorthToSouth,d=i.northIndicesWestToEast;o=n[t]={indices:r,westIndicesSouthToNorth:a,southIndicesEastToWest:s,eastIndicesNorthToSouth:c,northIndicesWestToEast:d}}return o};const M=[];function S(e,t){const r=new Array(t),n=new Array(e),o=new Array(t),i=new Array(e);let a;for(a=0;a<e;++a)i[a]=a,n[a]=e*t-1-a;for(a=0;a<t;++a)o[a]=(a+1)*e-1,r[a]=(t-a-1)*e;return{westIndicesSouthToNorth:r,southIndicesEastToWest:n,eastIndicesNorthToSouth:o,northIndicesWestToEast:i}}function x(e,t,r,n){let o=0;for(let i=0;i<t-1;++i){for(let t=0;t<e-1;++t){const t=o,i=t+e,a=i+1,s=t+1;r[n++]=t,r[n++]=i,r[n++]=s,r[n++]=s,r[n++]=i,r[n++]=a,++o}++o}}function A(e,t,r,n){let o=e[0];const i=e.length;for(let a=1;a<i;++a){const i=e[a];r[n++]=o,r[n++]=i,r[n++]=t,r[n++]=t,r[n++]=i,r[n++]=t+1,o=i,++t}return n}N.getRegularGridAndSkirtIndicesAndEdgeIndices=function(e,t){let n=M[e];r.defined(n)||(M[e]=n=[]);let o=n[t];if(!r.defined(o)){const r=e*t,a=(e-1)*(t-1)*6,s=2*e+2*t,c=r+s,d=a+6*Math.max(0,s-4),h=S(e,t),u=h.westIndicesSouthToNorth,l=h.southIndicesEastToWest,I=h.eastIndicesNorthToSouth,g=h.northIndicesWestToEast,m=i.IndexDatatype.createTypedArray(c,d);x(e,t,m,0),N.addSkirtIndices(u,l,I,g,r,m,a),o=n[t]={indices:m,westIndicesSouthToNorth:u,southIndicesEastToWest:l,eastIndicesNorthToSouth:I,northIndicesWestToEast:g,indexCountWithoutSkirts:a}}return o},N.addSkirtIndices=function(e,t,r,n,o,i,a){let s=o;a=A(e,s,i,a),s+=e.length,a=A(t,s,i,a),s+=t.length,a=A(r,s,i,a),s+=r.length,A(n,s,i,a)},N.heightmapTerrainQuality=.25,N.getEstimatedLevelZeroGeometricErrorForAHeightmap=function(e,t,r){return 2*e.maximumRadius*Math.PI*N.heightmapTerrainQuality/(t*r)},N.prototype.requestTileGeometry=s.DeveloperError.throwInstantiationError,N.prototype.getLevelMaximumGeometricError=s.DeveloperError.throwInstantiationError,N.prototype.getTileDataAvailable=s.DeveloperError.throwInstantiationError,N.prototype.loadTileDataAvailability=s.DeveloperError.throwInstantiationError;const C=32767,v=new t.Cartesian3,W=new t.Cartesian3,P=new t.Cartesian3,D=new t.Cartographic,k=new t.Cartesian2;function F(e,r,n,o,i,s,c,d,h){let u=Number.POSITIVE_INFINITY;const l=i.north,I=i.south;let g=i.east;const m=i.west;g<m&&(g+=a.CesiumMath.TWO_PI);const T=e.length;for(let i=0;i<T;++i){const T=e[i],f=n[T],E=o[T];D.longitude=a.CesiumMath.lerp(m,g,E.x),D.latitude=a.CesiumMath.lerp(I,l,E.y),D.height=f-r;const p=s.cartographicToCartesian(D,v);t.Matrix4.multiplyByPoint(c,p,p),t.Cartesian3.minimumByComponent(p,d,d),t.Cartesian3.maximumByComponent(p,h,h),u=Math.min(u,D.height)}return u}function H(e,t,n,o,i,s,c,h,u,l,I,g,m,T){const f=r.defined(c),E=u.north,p=u.south;let y=u.east;const N=u.west;y<N&&(y+=a.CesiumMath.TWO_PI);const w=n.length;for(let r=0;r<w;++r){const u=n[r],w=i[u],b=s[u];D.longitude=a.CesiumMath.lerp(N,y,b.x)+m,D.latitude=a.CesiumMath.lerp(p,E,b.y)+T,D.height=w-l;const M=h.cartographicToCartesian(D,v);if(f){const e=2*u;k.x=c[e],k.y=c[e+1]}let S,x;o.hasWebMercatorT&&(S=(d.WebMercatorProjection.geodeticLatitudeToMercatorAngle(D.latitude)-I)*g),o.hasGeodeticSurfaceNormals&&(x=h.geodeticSurfaceNormal(M)),t=o.encode(e,t,M,b,D.height,k,S,x)}}function _(e,t){let n;return"function"==typeof e.slice&&(n=e.slice(),"function"!=typeof n.sort&&(n=void 0)),r.defined(n)||(n=Array.prototype.slice.call(e)),n.sort(t),n}return h((function(s,h){const u=s.quantizedVertices,l=u.length/3,I=s.octEncodedNormals,g=s.westIndices.length+s.eastIndices.length+s.southIndices.length+s.northIndices.length,m=s.includeWebMercatorT,T=s.exaggeration,f=s.exaggerationRelativeHeight,E=1!==T,p=n.Rectangle.clone(s.rectangle),y=p.west,w=p.south,b=p.east,M=p.north,S=n.Ellipsoid.clone(s.ellipsoid),x=s.minimumHeight,A=s.maximumHeight,G=s.relativeToCenter,V=c.Transforms.eastNorthUpToFixedFrame(G,S),Y=t.Matrix4.inverseTransformation(V,new t.Matrix4);let O,B;m&&(O=d.WebMercatorProjection.geodeticLatitudeToMercatorAngle(w),B=1/(d.WebMercatorProjection.geodeticLatitudeToMercatorAngle(M)-O));const R=u.subarray(0,l),L=u.subarray(l,2*l),j=u.subarray(2*l,3*l),z=r.defined(I),U=new Array(l),q=new Array(l),Q=new Array(l),K=m?new Array(l):[],X=E?new Array(l):[],Z=W;Z.x=Number.POSITIVE_INFINITY,Z.y=Number.POSITIVE_INFINITY,Z.z=Number.POSITIVE_INFINITY;const J=P;J.x=Number.NEGATIVE_INFINITY,J.y=Number.NEGATIVE_INFINITY,J.z=Number.NEGATIVE_INFINITY;let $=Number.POSITIVE_INFINITY,ee=Number.NEGATIVE_INFINITY,te=Number.POSITIVE_INFINITY,re=Number.NEGATIVE_INFINITY;for(let e=0;e<l;++e){const r=R[e],n=L[e],o=r/C,i=n/C,s=a.CesiumMath.lerp(x,A,j[e]/C);D.longitude=a.CesiumMath.lerp(y,b,o),D.latitude=a.CesiumMath.lerp(w,M,i),D.height=s,$=Math.min(D.longitude,$),ee=Math.max(D.longitude,ee),te=Math.min(D.latitude,te),re=Math.max(D.latitude,re);const c=S.cartographicToCartesian(D);U[e]=new t.Cartesian2(o,i),q[e]=s,Q[e]=c,m&&(K[e]=(d.WebMercatorProjection.geodeticLatitudeToMercatorAngle(D.latitude)-O)*B),E&&(X[e]=S.geodeticSurfaceNormal(c)),t.Matrix4.multiplyByPoint(Y,c,v),t.Cartesian3.minimumByComponent(v,Z,Z),t.Cartesian3.maximumByComponent(v,J,J)}const ne=_(s.westIndices,(function(e,t){return U[e].y-U[t].y})),oe=_(s.eastIndices,(function(e,t){return U[t].y-U[e].y})),ie=_(s.southIndices,(function(e,t){return U[t].x-U[e].x})),ae=_(s.northIndices,(function(e,t){return U[e].x-U[t].x}));let se;if(x<0){se=new o.EllipsoidalOccluder(S).computeHorizonCullingPointPossiblyUnderEllipsoid(G,Q,x)}let ce=x;ce=Math.min(ce,F(s.westIndices,s.westSkirtHeight,q,U,p,S,Y,Z,J)),ce=Math.min(ce,F(s.southIndices,s.southSkirtHeight,q,U,p,S,Y,Z,J)),ce=Math.min(ce,F(s.eastIndices,s.eastSkirtHeight,q,U,p,S,Y,Z,J)),ce=Math.min(ce,F(s.northIndices,s.northSkirtHeight,q,U,p,S,Y,Z,J));const de=new e.AxisAlignedBoundingBox(Z,J,G),he=new o.TerrainEncoding(G,de,ce,A,V,z,m,E,T,f),ue=he.stride,le=new Float32Array(l*ue+g*ue);let Ie=0;for(let e=0;e<l;++e){if(z){const t=2*e;k.x=I[t],k.y=I[t+1]}Ie=he.encode(le,Ie,Q[e],U[e],q[e],k,K[e],X[e])}const ge=Math.max(0,2*(g-4)),me=s.indices.length+3*ge,Te=i.IndexDatatype.createTypedArray(l+g,me);Te.set(s.indices,0);const fe=1e-4,Ee=(ee-$)*fe,pe=(re-te)*fe,ye=-Ee,Ne=Ee,we=pe,be=-pe;let Me=l*ue;return H(le,Me,ne,he,q,U,I,S,p,s.westSkirtHeight,O,B,ye,0),Me+=s.westIndices.length*ue,H(le,Me,ie,he,q,U,I,S,p,s.southSkirtHeight,O,B,0,be),Me+=s.southIndices.length*ue,H(le,Me,oe,he,q,U,I,S,p,s.eastSkirtHeight,O,B,Ne,0),Me+=s.eastIndices.length*ue,H(le,Me,ae,he,q,U,I,S,p,s.northSkirtHeight,O,B,0,we),N.addSkirtIndices(ne,ie,oe,ae,l,Te,s.indices.length),h.push(le.buffer,Te.buffer),{vertices:le.buffer,indices:Te.buffer,westIndicesSouthToNorth:ne,southIndicesEastToWest:ie,eastIndicesNorthToSouth:oe,northIndicesWestToEast:ae,vertexStride:ue,center:G,minimumHeight:x,maximumHeight:A,occludeePointInScaledSpace:se,encoding:he,indexCountWithoutSkirts:s.indices.length}}))}));
