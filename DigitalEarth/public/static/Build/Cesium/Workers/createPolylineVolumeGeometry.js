/**
 * @license
 * Cesium - https://github.com/CesiumGS/cesium
 * Version 1.96
 *
 * Copyright 2011-2022 Cesium Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Columbus View (Pat. Pend.)
 *
 * Portions licensed separately.
 * See https://github.com/CesiumGS/cesium/blob/main/LICENSE.md for full licensing details.
 */
define(["./defined-b681f02d","./Rectangle-0610a1c7","./arrayRemoveDuplicates-bbac3e0e","./BoundingRectangle-3739fff5","./Transforms-99c89742","./Matrix4-d3db9505","./ComponentDatatype-46a1cf7a","./PolylineVolumeGeometryLibrary-9b126e47","./Check-436535f3","./GeometryAttribute-ef6ca9ab","./GeometryAttributes-18ccc0d6","./GeometryPipeline-7151dba5","./IndexDatatype-1b44a4e6","./Math-5b6faca9","./PolygonPipeline-5a6c6b44","./VertexFormat-1359575c","./Interval-49d6e8fc","./_commonjsHelpers-a32ac251","./combine-8b9ba6cb","./RequestType-e53aab71","./RuntimeError-14317824","./WebGLConstants-f100e3dd","./EllipsoidTangentPlane-34e5c0ac","./AxisAlignedBoundingBox-321a482b","./IntersectionTests-3ac7f0c9","./Plane-172c23d7","./PolylinePipeline-c42c443b","./EllipsoidGeodesic-bd79a412","./EllipsoidRhumbLine-65d4aeca","./Matrix2-7384588e","./AttributeCompression-055d015a","./EncodedCartesian3-e8f321af"],(function(e,t,n,o,a,i,r,l,s,c,p,d,u,m,y,g,f,h,b,P,_,E,k,v,x,C,L,V,F,T,A,G){"use strict";function D(n){const o=(n=e.defaultValue(n,e.defaultValue.EMPTY_OBJECT)).polylinePositions,a=n.shapePositions;this._positions=o,this._shape=a,this._ellipsoid=t.Ellipsoid.clone(e.defaultValue(n.ellipsoid,t.Ellipsoid.WGS84)),this._cornerType=e.defaultValue(n.cornerType,l.CornerType.ROUNDED),this._vertexFormat=g.VertexFormat.clone(e.defaultValue(n.vertexFormat,g.VertexFormat.DEFAULT)),this._granularity=e.defaultValue(n.granularity,m.CesiumMath.RADIANS_PER_DEGREE),this._workerName="createPolylineVolumeGeometry";let r=1+o.length*i.Cartesian3.packedLength;r+=1+a.length*i.Cartesian2.packedLength,this.packedLength=r+t.Ellipsoid.packedLength+g.VertexFormat.packedLength+2}D.pack=function(n,o,a){let r;a=e.defaultValue(a,0);const l=n._positions;let s=l.length;for(o[a++]=s,r=0;r<s;++r,a+=i.Cartesian3.packedLength)i.Cartesian3.pack(l[r],o,a);const c=n._shape;for(s=c.length,o[a++]=s,r=0;r<s;++r,a+=i.Cartesian2.packedLength)i.Cartesian2.pack(c[r],o,a);return t.Ellipsoid.pack(n._ellipsoid,o,a),a+=t.Ellipsoid.packedLength,g.VertexFormat.pack(n._vertexFormat,o,a),a+=g.VertexFormat.packedLength,o[a++]=n._cornerType,o[a]=n._granularity,o};const R=t.Ellipsoid.clone(t.Ellipsoid.UNIT_SPHERE),w=new g.VertexFormat,B={polylinePositions:void 0,shapePositions:void 0,ellipsoid:R,vertexFormat:w,cornerType:void 0,granularity:void 0};D.unpack=function(n,o,a){let r;o=e.defaultValue(o,0);let l=n[o++];const s=new Array(l);for(r=0;r<l;++r,o+=i.Cartesian3.packedLength)s[r]=i.Cartesian3.unpack(n,o);l=n[o++];const c=new Array(l);for(r=0;r<l;++r,o+=i.Cartesian2.packedLength)c[r]=i.Cartesian2.unpack(n,o);const p=t.Ellipsoid.unpack(n,o,R);o+=t.Ellipsoid.packedLength;const d=g.VertexFormat.unpack(n,o,w);o+=g.VertexFormat.packedLength;const u=n[o++],m=n[o];return e.defined(a)?(a._positions=s,a._shape=c,a._ellipsoid=t.Ellipsoid.clone(p,a._ellipsoid),a._vertexFormat=g.VertexFormat.clone(d,a._vertexFormat),a._cornerType=u,a._granularity=m,a):(B.polylinePositions=s,B.shapePositions=c,B.cornerType=u,B.granularity=m,new D(B))};const I=new o.BoundingRectangle;return D.createGeometry=function(e){const t=e._positions,s=n.arrayRemoveDuplicates(t,i.Cartesian3.equalsEpsilon);let m=e._shape;if(m=l.PolylineVolumeGeometryLibrary.removeDuplicatesFromShape(m),s.length<2||m.length<3)return;y.PolygonPipeline.computeWindingOrder2D(m)===y.WindingOrder.CLOCKWISE&&m.reverse();const g=o.BoundingRectangle.fromPoints(m,I);return function(e,t,n,o){const i=new p.GeometryAttributes;o.position&&(i.position=new c.GeometryAttribute({componentDatatype:r.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:e}));const s=t.length,m=e.length/3,g=(m-2*s)/(2*s),f=y.PolygonPipeline.triangulate(t),h=(g-1)*s*6+2*f.length,b=u.IndexDatatype.createTypedArray(m,h);let P,_,E,k,v,x;const C=2*s;let L=0;for(P=0;P<g-1;P++){for(_=0;_<s-1;_++)E=2*_+P*s*2,x=E+C,k=E+1,v=k+C,b[L++]=k,b[L++]=E,b[L++]=v,b[L++]=v,b[L++]=E,b[L++]=x;E=2*s-2+P*s*2,k=E+1,v=k+C,x=E+C,b[L++]=k,b[L++]=E,b[L++]=v,b[L++]=v,b[L++]=E,b[L++]=x}if(o.st||o.tangent||o.bitangent){const e=new Float32Array(2*m),o=1/(g-1),a=1/n.height,l=n.height/2;let p,d,u=0;for(P=0;P<g;P++){for(p=P*o,d=a*(t[0].y+l),e[u++]=p,e[u++]=d,_=1;_<s;_++)d=a*(t[_].y+l),e[u++]=p,e[u++]=d,e[u++]=p,e[u++]=d;d=a*(t[0].y+l),e[u++]=p,e[u++]=d}for(_=0;_<s;_++)p=0,d=a*(t[_].y+l),e[u++]=p,e[u++]=d;for(_=0;_<s;_++)p=(g-1)*o,d=a*(t[_].y+l),e[u++]=p,e[u++]=d;i.st=new c.GeometryAttribute({componentDatatype:r.ComponentDatatype.FLOAT,componentsPerAttribute:2,values:new Float32Array(e)})}const V=m-2*s;for(P=0;P<f.length;P+=3){const e=f[P]+V,t=f[P+1]+V,n=f[P+2]+V;b[L++]=e,b[L++]=t,b[L++]=n,b[L++]=n+s,b[L++]=t+s,b[L++]=e+s}let F=new c.Geometry({attributes:i,indices:b,boundingSphere:a.BoundingSphere.fromVertices(e),primitiveType:c.PrimitiveType.TRIANGLES});if(o.normal&&(F=d.GeometryPipeline.computeNormal(F)),o.tangent||o.bitangent){try{F=d.GeometryPipeline.computeTangentAndBitangent(F)}catch(e){l.oneTimeWarning("polyline-volume-tangent-bitangent","Unable to compute tangents and bitangents for polyline volume geometry")}o.tangent||(F.attributes.tangent=void 0),o.bitangent||(F.attributes.bitangent=void 0),o.st||(F.attributes.st=void 0)}return F}(l.PolylineVolumeGeometryLibrary.computePositions(s,m,g,e,!0),m,g,e._vertexFormat)},function(n,o){return e.defined(o)&&(n=D.unpack(n,o)),n._ellipsoid=t.Ellipsoid.clone(n._ellipsoid),D.createGeometry(n)}}));
