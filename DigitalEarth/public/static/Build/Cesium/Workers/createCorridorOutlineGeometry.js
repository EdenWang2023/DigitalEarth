/**
 * @license
 * Cesium - https://github.com/CesiumGS/cesium
 * Version 1.96
 *
 * Copyright 2011-2022 Cesium Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Columbus View (Pat. Pend.)
 *
 * Portions licensed separately.
 * See https://github.com/CesiumGS/cesium/blob/main/LICENSE.md for full licensing details.
 */
define(["./arrayRemoveDuplicates-bbac3e0e","./Transforms-99c89742","./Matrix4-d3db9505","./Check-436535f3","./ComponentDatatype-46a1cf7a","./PolylineVolumeGeometryLibrary-9b126e47","./CorridorGeometryLibrary-9a057432","./defined-b681f02d","./Rectangle-0610a1c7","./GeometryAttribute-ef6ca9ab","./GeometryAttributes-18ccc0d6","./GeometryOffsetAttribute-3e5f3e97","./IndexDatatype-1b44a4e6","./Math-5b6faca9","./PolygonPipeline-5a6c6b44","./Interval-49d6e8fc","./_commonjsHelpers-a32ac251","./combine-8b9ba6cb","./RequestType-e53aab71","./RuntimeError-14317824","./WebGLConstants-f100e3dd","./EllipsoidTangentPlane-34e5c0ac","./AxisAlignedBoundingBox-321a482b","./IntersectionTests-3ac7f0c9","./Plane-172c23d7","./PolylinePipeline-c42c443b","./EllipsoidGeodesic-bd79a412","./EllipsoidRhumbLine-65d4aeca","./Matrix2-7384588e"],(function(e,t,i,r,o,n,s,a,l,d,u,c,p,f,h,y,g,b,m,A,_,E,C,G,T,P,v,w,L){"use strict";const D=new i.Cartesian3,x=new i.Cartesian3,k=new i.Cartesian3;function H(e,t){const r=[],l=e.positions,c=e.corners,f=e.endPositions,h=new u.GeometryAttributes;let y,g,b,m=0,A=0,_=0;for(g=0;g<l.length;g+=2)b=l[g].length-3,m+=b,_+=b/3*4,A+=l[g+1].length-3;for(m+=3,A+=3,g=0;g<c.length;g++){y=c[g];const e=c[g].leftPositions;a.defined(e)?(b=e.length,m+=b,_+=b/3*2):(b=c[g].rightPositions.length,A+=b,_+=b/3*2)}const E=a.defined(f);let C;E&&(C=f[0].length-3,m+=C,A+=C,C/=3,_+=4*C);const G=m+A,T=new Float64Array(G);let P,v,w,L,H,N,O=0,V=G-1;const I=C/2,M=p.IndexDatatype.createTypedArray(G/3,_+4);let R=0;if(M[R++]=O/3,M[R++]=(V-2)/3,E){r.push(O/3),N=D,H=x;const e=f[0];for(g=0;g<I;g++)N=i.Cartesian3.fromArray(e,3*(I-1-g),N),H=i.Cartesian3.fromArray(e,3*(I+g),H),s.CorridorGeometryLibrary.addAttribute(T,H,O),s.CorridorGeometryLibrary.addAttribute(T,N,void 0,V),v=O/3,L=v+1,P=(V-2)/3,w=P-1,M[R++]=P,M[R++]=w,M[R++]=v,M[R++]=L,O+=3,V-=3}let S=0,B=l[S++],U=l[S++];for(T.set(B,O),T.set(U,V-U.length+1),b=U.length-3,r.push(O/3,(V-2)/3),g=0;g<b;g+=3)v=O/3,L=v+1,P=(V-2)/3,w=P-1,M[R++]=P,M[R++]=w,M[R++]=v,M[R++]=L,O+=3,V-=3;for(g=0;g<c.length;g++){let e;y=c[g];const o=y.leftPositions,d=y.rightPositions;let u,p=k;if(a.defined(o)){for(V-=3,u=w,r.push(L),e=0;e<o.length/3;e++)p=i.Cartesian3.fromArray(o,3*e,p),M[R++]=u-e-1,M[R++]=u-e,s.CorridorGeometryLibrary.addAttribute(T,p,void 0,V),V-=3;r.push(u-Math.floor(o.length/6)),t===n.CornerType.BEVELED&&r.push((V-2)/3+1),O+=3}else{for(O+=3,u=L,r.push(w),e=0;e<d.length/3;e++)p=i.Cartesian3.fromArray(d,3*e,p),M[R++]=u+e,M[R++]=u+e+1,s.CorridorGeometryLibrary.addAttribute(T,p,O),O+=3;r.push(u+Math.floor(d.length/6)),t===n.CornerType.BEVELED&&r.push(O/3-1),V-=3}for(B=l[S++],U=l[S++],B.splice(0,3),U.splice(U.length-3,3),T.set(B,O),T.set(U,V-U.length+1),b=U.length-3,e=0;e<U.length;e+=3)L=O/3,v=L-1,w=(V-2)/3,P=w+1,M[R++]=P,M[R++]=w,M[R++]=v,M[R++]=L,O+=3,V-=3;O-=3,V+=3,r.push(O/3,(V-2)/3)}if(E){O+=3,V-=3,N=D,H=x;const e=f[1];for(g=0;g<I;g++)N=i.Cartesian3.fromArray(e,3*(C-g-1),N),H=i.Cartesian3.fromArray(e,3*g,H),s.CorridorGeometryLibrary.addAttribute(T,N,void 0,V),s.CorridorGeometryLibrary.addAttribute(T,H,O),L=O/3,v=L-1,w=(V-2)/3,P=w+1,M[R++]=P,M[R++]=w,M[R++]=v,M[R++]=L,O+=3,V-=3;r.push(O/3)}else r.push(O/3,(V-2)/3);return M[R++]=O/3,M[R++]=(V-2)/3,h.position=new d.GeometryAttribute({componentDatatype:o.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:T}),{attributes:h,indices:M,wallIndices:r}}function N(e){const t=(e=a.defaultValue(e,a.defaultValue.EMPTY_OBJECT)).positions,r=e.width,o=a.defaultValue(e.height,0),s=a.defaultValue(e.extrudedHeight,o);this._positions=t,this._ellipsoid=l.Ellipsoid.clone(a.defaultValue(e.ellipsoid,l.Ellipsoid.WGS84)),this._width=r,this._height=Math.max(o,s),this._extrudedHeight=Math.min(o,s),this._cornerType=a.defaultValue(e.cornerType,n.CornerType.ROUNDED),this._granularity=a.defaultValue(e.granularity,f.CesiumMath.RADIANS_PER_DEGREE),this._offsetAttribute=e.offsetAttribute,this._workerName="createCorridorOutlineGeometry",this.packedLength=1+t.length*i.Cartesian3.packedLength+l.Ellipsoid.packedLength+6}N.pack=function(e,t,r){r=a.defaultValue(r,0);const o=e._positions,n=o.length;t[r++]=n;for(let e=0;e<n;++e,r+=i.Cartesian3.packedLength)i.Cartesian3.pack(o[e],t,r);return l.Ellipsoid.pack(e._ellipsoid,t,r),r+=l.Ellipsoid.packedLength,t[r++]=e._width,t[r++]=e._height,t[r++]=e._extrudedHeight,t[r++]=e._cornerType,t[r++]=e._granularity,t[r]=a.defaultValue(e._offsetAttribute,-1),t};const O=l.Ellipsoid.clone(l.Ellipsoid.UNIT_SPHERE),V={positions:void 0,ellipsoid:O,width:void 0,height:void 0,extrudedHeight:void 0,cornerType:void 0,granularity:void 0,offsetAttribute:void 0};return N.unpack=function(e,t,r){t=a.defaultValue(t,0);const o=e[t++],n=new Array(o);for(let r=0;r<o;++r,t+=i.Cartesian3.packedLength)n[r]=i.Cartesian3.unpack(e,t);const s=l.Ellipsoid.unpack(e,t,O);t+=l.Ellipsoid.packedLength;const d=e[t++],u=e[t++],c=e[t++],p=e[t++],f=e[t++],h=e[t];return a.defined(r)?(r._positions=n,r._ellipsoid=l.Ellipsoid.clone(s,r._ellipsoid),r._width=d,r._height=u,r._extrudedHeight=c,r._cornerType=p,r._granularity=f,r._offsetAttribute=-1===h?void 0:h,r):(V.positions=n,V.width=d,V.height=u,V.extrudedHeight=c,V.cornerType=p,V.granularity=f,V.offsetAttribute=-1===h?void 0:h,new N(V))},N.createGeometry=function(r){let n=r._positions;const l=r._width,u=r._ellipsoid;n=function(e,t){for(let i=0;i<e.length;i++)e[i]=t.scaleToGeodeticSurface(e[i],e[i]);return e}(n,u);const y=e.arrayRemoveDuplicates(n,i.Cartesian3.equalsEpsilon);if(y.length<2||l<=0)return;const g=r._height,b=r._extrudedHeight,m=!f.CesiumMath.equalsEpsilon(g,b,0,f.CesiumMath.EPSILON2),A={ellipsoid:u,positions:y,width:l,cornerType:r._cornerType,granularity:r._granularity,saveAttributes:!1};let _;if(m)A.height=g,A.extrudedHeight=b,A.offsetAttribute=r._offsetAttribute,_=function(e){const t=e.ellipsoid,i=H(s.CorridorGeometryLibrary.computePositions(e),e.cornerType),r=i.wallIndices,n=e.height,l=e.extrudedHeight,u=i.attributes,f=i.indices;let y=u.position.values,g=y.length,b=new Float64Array(g);b.set(y);const m=new Float64Array(2*g);if(y=h.PolygonPipeline.scaleToGeodeticHeight(y,n,t),b=h.PolygonPipeline.scaleToGeodeticHeight(b,l,t),m.set(y),m.set(b,g),u.position.values=m,g/=3,a.defined(e.offsetAttribute)){let t=new Uint8Array(2*g);if(e.offsetAttribute===c.GeometryOffsetAttribute.TOP)t=t.fill(1,0,g);else{const i=e.offsetAttribute===c.GeometryOffsetAttribute.NONE?0:1;t=t.fill(i)}u.applyOffset=new d.GeometryAttribute({componentDatatype:o.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:t})}let A;const _=f.length,E=p.IndexDatatype.createTypedArray(m.length/3,2*(_+r.length));E.set(f);let C,G,T=_;for(A=0;A<_;A+=2){const e=f[A],t=f[A+1];E[T++]=e+g,E[T++]=t+g}for(A=0;A<r.length;A++)C=r[A],G=C+g,E[T++]=C,E[T++]=G;return{attributes:u,indices:E}}(A);else{if(_=H(s.CorridorGeometryLibrary.computePositions(A),A.cornerType),_.attributes.position.values=h.PolygonPipeline.scaleToGeodeticHeight(_.attributes.position.values,g,u),a.defined(r._offsetAttribute)){const e=_.attributes.position.values.length,t=r._offsetAttribute===c.GeometryOffsetAttribute.NONE?0:1,i=new Uint8Array(e/3).fill(t);_.attributes.applyOffset=new d.GeometryAttribute({componentDatatype:o.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:i})}}const E=_.attributes,C=t.BoundingSphere.fromVertices(E.position.values,void 0,3);return new d.Geometry({attributes:E,indices:_.indices,primitiveType:d.PrimitiveType.LINES,boundingSphere:C,offsetAttribute:r._offsetAttribute})},function(e,t){return a.defined(t)&&(e=N.unpack(e,t)),e._ellipsoid=l.Ellipsoid.clone(e._ellipsoid),N.createGeometry(e)}}));
