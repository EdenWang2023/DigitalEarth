/**
 * @license
 * Cesium - https://github.com/CesiumGS/cesium
 * Version 1.96
 *
 * Copyright 2011-2022 Cesium Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Columbus View (Pat. Pend.)
 *
 * Portions licensed separately.
 * See https://github.com/CesiumGS/cesium/blob/main/LICENSE.md for full licensing details.
 */
define(["./arrayRemoveDuplicates-bbac3e0e","./Transforms-99c89742","./Matrix4-d3db9505","./Check-436535f3","./ComponentDatatype-46a1cf7a","./PolylineVolumeGeometryLibrary-9b126e47","./CorridorGeometryLibrary-9a057432","./defined-b681f02d","./Rectangle-0610a1c7","./GeometryAttribute-ef6ca9ab","./GeometryAttributes-18ccc0d6","./GeometryOffsetAttribute-3e5f3e97","./IndexDatatype-1b44a4e6","./Math-5b6faca9","./PolygonPipeline-5a6c6b44","./VertexFormat-1359575c","./Interval-49d6e8fc","./_commonjsHelpers-a32ac251","./combine-8b9ba6cb","./RequestType-e53aab71","./RuntimeError-14317824","./WebGLConstants-f100e3dd","./EllipsoidTangentPlane-34e5c0ac","./AxisAlignedBoundingBox-321a482b","./IntersectionTests-3ac7f0c9","./Plane-172c23d7","./PolylinePipeline-c42c443b","./EllipsoidGeodesic-bd79a412","./EllipsoidRhumbLine-65d4aeca","./Matrix2-7384588e"],(function(t,e,r,a,n,i,o,s,l,d,u,c,m,y,p,f,g,C,b,h,A,w,v,_,G,T,E,F,L,x){"use strict";const D=new r.Cartesian3,V=new r.Cartesian3,N=new r.Cartesian3,P=new r.Cartesian3,I=new r.Cartesian3,O=new r.Cartesian3,S=new r.Cartesian3,M=new r.Cartesian3;function k(t,e){for(let r=0;r<t.length;r++)t[r]=e.scaleToGeodeticSurface(t[r],t[r]);return t}function R(t,e,a,n,i,s){const l=t.normals,d=t.tangents,u=t.bitangents,c=r.Cartesian3.normalize(r.Cartesian3.cross(a,e,S),S);s.normal&&o.CorridorGeometryLibrary.addAttribute(l,e,n,i),s.tangent&&o.CorridorGeometryLibrary.addAttribute(d,c,n,i),s.bitangent&&o.CorridorGeometryLibrary.addAttribute(u,a,n,i)}function B(t,e,a){const i=t.positions,l=t.corners,c=t.endPositions,y=t.lefts,p=t.normals,f=new u.GeometryAttributes;let g,C,b,h,A,w,v,_,G,T=0,E=0,F=0,L=D;if(0===l.length){for(C=0;C<i.length;C+=2)E+=i[C].length,T+=i[C+1].length;v=T+E,F=v-6,G=m.IndexDatatype.createTypedArray(v/3,F),w=new Float64Array(v);const t=e.normal?new Float32Array(v):void 0;_={normals:t,tangents:e.tangent?new Float32Array(v):void 0,bitangents:e.bitangent?new Float32Array(v):void 0};let n,s,l,d,u=0,c=v-1,y=0;const p=i.length;for(C=0;C<p;C+=2){const e=i[C],m=i[C+1];w.set(e,u),w.set(m,c-m.length+1);for(let i=0,f=e.length;i<f;i+=3)h=a.geodeticSurfaceNormal(r.Cartesian3.fromArray(e,i,S),S),A=a.geodeticSurfaceNormal(r.Cartesian3.fromArray(m,f-3-i,M),M),L=r.Cartesian3.normalize(r.Cartesian3.add(h,A,L),L),o.CorridorGeometryLibrary.addAttribute(t,L,u,c),C===p-2&&i===f-3||(d=u/3,l=d+1,s=(c-2)/3,n=s-1,G[y++]=n,G[y++]=s,G[y++]=l,G[y++]=l,G[y++]=s,G[y++]=d,u+=3,c-=3)}}else{for(C=0;C<i.length;C+=2)b=i[C].length-3,T+=b,F+=2*b,E+=i[C+1].length-3;for(T+=3,E+=3,C=0;C<l.length;C++){g=l[C];const t=l[C].leftPositions;s.defined(t)?(b=t.length,T+=b,F+=b):(b=l[C].rightPositions.length,E+=b,F+=b)}const t=s.defined(c);let n;t&&(n=c[0].length-3,T+=n,E+=n,n/=3,F+=6*n);const d=T+E;w=new Float64Array(d);_={normals:e.normal?new Float32Array(d):void 0,tangents:e.tangent?new Float32Array(d):void 0,bitangents:e.bitangent?new Float32Array(d):void 0};let u,f,h,A,v,L,x=0,I=d-1,k=D,B=V;const H=n/2;G=m.IndexDatatype.createTypedArray(d/3,F);let z=0;if(t){L=N,v=P;const t=c[0];for(k=r.Cartesian3.fromArray(p,0,k),B=r.Cartesian3.fromArray(y,0,B),C=0;C<H;C++)L=r.Cartesian3.fromArray(t,3*(H-1-C),L),v=r.Cartesian3.fromArray(t,3*(H+C),v),o.CorridorGeometryLibrary.addAttribute(w,v,x),o.CorridorGeometryLibrary.addAttribute(w,L,void 0,I),R(_,k,B,x,I,e),f=x/3,A=f+1,u=(I-2)/3,h=u-1,G[z++]=u,G[z++]=f,G[z++]=h,G[z++]=h,G[z++]=f,G[z++]=A,x+=3,I-=3}let U,Y,q=0,W=0,j=i[q++],J=i[q++];for(w.set(j,x),w.set(J,I-J.length+1),B=r.Cartesian3.fromArray(y,W,B),b=J.length-3,C=0;C<b;C+=3)U=a.geodeticSurfaceNormal(r.Cartesian3.fromArray(j,C,S),S),Y=a.geodeticSurfaceNormal(r.Cartesian3.fromArray(J,b-C,M),M),k=r.Cartesian3.normalize(r.Cartesian3.add(U,Y,k),k),R(_,k,B,x,I,e),f=x/3,A=f+1,u=(I-2)/3,h=u-1,G[z++]=u,G[z++]=f,G[z++]=h,G[z++]=h,G[z++]=f,G[z++]=A,x+=3,I-=3;for(U=a.geodeticSurfaceNormal(r.Cartesian3.fromArray(j,b,S),S),Y=a.geodeticSurfaceNormal(r.Cartesian3.fromArray(J,b,M),M),k=r.Cartesian3.normalize(r.Cartesian3.add(U,Y,k),k),W+=3,C=0;C<l.length;C++){let t;g=l[C];const n=g.leftPositions,d=g.rightPositions;let c,m,v=O,T=N,E=P;if(k=r.Cartesian3.fromArray(p,W,k),s.defined(n)){for(R(_,k,B,void 0,I,e),I-=3,c=A,m=h,t=0;t<n.length/3;t++)v=r.Cartesian3.fromArray(n,3*t,v),G[z++]=c,G[z++]=m-t-1,G[z++]=m-t,o.CorridorGeometryLibrary.addAttribute(w,v,void 0,I),T=r.Cartesian3.fromArray(w,3*(m-t-1),T),E=r.Cartesian3.fromArray(w,3*c,E),B=r.Cartesian3.normalize(r.Cartesian3.subtract(T,E,B),B),R(_,k,B,void 0,I,e),I-=3;v=r.Cartesian3.fromArray(w,3*c,v),T=r.Cartesian3.subtract(r.Cartesian3.fromArray(w,3*m,T),v,T),E=r.Cartesian3.subtract(r.Cartesian3.fromArray(w,3*(m-t),E),v,E),B=r.Cartesian3.normalize(r.Cartesian3.add(T,E,B),B),R(_,k,B,x,void 0,e),x+=3}else{for(R(_,k,B,x,void 0,e),x+=3,c=h,m=A,t=0;t<d.length/3;t++)v=r.Cartesian3.fromArray(d,3*t,v),G[z++]=c,G[z++]=m+t,G[z++]=m+t+1,o.CorridorGeometryLibrary.addAttribute(w,v,x),T=r.Cartesian3.fromArray(w,3*c,T),E=r.Cartesian3.fromArray(w,3*(m+t),E),B=r.Cartesian3.normalize(r.Cartesian3.subtract(T,E,B),B),R(_,k,B,x,void 0,e),x+=3;v=r.Cartesian3.fromArray(w,3*c,v),T=r.Cartesian3.subtract(r.Cartesian3.fromArray(w,3*(m+t),T),v,T),E=r.Cartesian3.subtract(r.Cartesian3.fromArray(w,3*m,E),v,E),B=r.Cartesian3.normalize(r.Cartesian3.negate(r.Cartesian3.add(E,T,B),B),B),R(_,k,B,void 0,I,e),I-=3}for(j=i[q++],J=i[q++],j.splice(0,3),J.splice(J.length-3,3),w.set(j,x),w.set(J,I-J.length+1),b=J.length-3,W+=3,B=r.Cartesian3.fromArray(y,W,B),t=0;t<J.length;t+=3)U=a.geodeticSurfaceNormal(r.Cartesian3.fromArray(j,t,S),S),Y=a.geodeticSurfaceNormal(r.Cartesian3.fromArray(J,b-t,M),M),k=r.Cartesian3.normalize(r.Cartesian3.add(U,Y,k),k),R(_,k,B,x,I,e),A=x/3,f=A-1,h=(I-2)/3,u=h+1,G[z++]=u,G[z++]=f,G[z++]=h,G[z++]=h,G[z++]=f,G[z++]=A,x+=3,I-=3;x-=3,I+=3}if(k=r.Cartesian3.fromArray(p,p.length-3,k),R(_,k,B,x,I,e),t){x+=3,I-=3,L=N,v=P;const t=c[1];for(C=0;C<H;C++)L=r.Cartesian3.fromArray(t,3*(n-C-1),L),v=r.Cartesian3.fromArray(t,3*C,v),o.CorridorGeometryLibrary.addAttribute(w,L,void 0,I),o.CorridorGeometryLibrary.addAttribute(w,v,x),R(_,k,B,x,I,e),A=x/3,f=A-1,h=(I-2)/3,u=h+1,G[z++]=u,G[z++]=f,G[z++]=h,G[z++]=h,G[z++]=f,G[z++]=A,x+=3,I-=3}}if(f.position=new d.GeometryAttribute({componentDatatype:n.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:w}),e.st){const t=new Float32Array(v/3*2);let e,a,i=0;if(T/=3,E/=3,T===E){const e=r.Cartesian3.unpackArray(w);let a=r.Cartesian3.multiplyByScalar(r.Cartesian3.add(e.shift(),e.pop()),.5,new r.Cartesian3),n=0;const o=[];let s=0;for(;e.length;){const t=r.Cartesian3.multiplyByScalar(r.Cartesian3.add(e.shift(),e.pop()),.5,new r.Cartesian3);n=r.Cartesian3.distance(t,a),o.push(n),s+=n,a=t}t[i++]=0,t[i++]=0;let l=2*(T+E)-1;t[l--]=1,t[l--]=0,n=0;for(let e=0,r=o.length;e<r;e++){n+=o[e];const r=n/s;t[i++]=r,t[i++]=0,t[l--]=1,t[l--]=r}}else{for(a=1/(T-1),e=1/(E-1),C=0;C<E;C++)t[i++]=C*e,t[i++]=0;for(C=T;C>0;C--)t[i++]=(C-1)*a,t[i++]=1}f.st=new d.GeometryAttribute({componentDatatype:n.ComponentDatatype.FLOAT,componentsPerAttribute:2,values:t})}return e.normal&&(f.normal=new d.GeometryAttribute({componentDatatype:n.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:_.normals})),e.tangent&&(f.tangent=new d.GeometryAttribute({componentDatatype:n.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:_.tangents})),e.bitangent&&(f.bitangent=new d.GeometryAttribute({componentDatatype:n.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:_.bitangents})),{attributes:f,indices:G}}function H(t,e,r){r[e++]=t[0],r[e++]=t[1],r[e++]=t[2];for(let a=3;a<t.length;a+=3){const n=t[a],i=t[a+1],o=t[a+2];r[e++]=n,r[e++]=i,r[e++]=o,r[e++]=n,r[e++]=i,r[e++]=o}return r[e++]=t[0],r[e++]=t[1],r[e++]=t[2],r}function z(t,e){const a=new f.VertexFormat({position:e.position,normal:e.normal||e.bitangent||t.shadowVolume,tangent:e.tangent,bitangent:e.normal||e.bitangent,st:e.st}),i=t.ellipsoid,l=B(o.CorridorGeometryLibrary.computePositions(t),a,i),u=t.height,y=t.extrudedHeight;let g=l.attributes;const C=l.indices;let b=g.position.values,h=b.length;const A=new Float64Array(6*h);let w=new Float64Array(h);w.set(b);let v,_=new Float64Array(4*h);b=p.PolygonPipeline.scaleToGeodeticHeight(b,u,i),_=H(b,0,_),w=p.PolygonPipeline.scaleToGeodeticHeight(w,y,i),_=H(w,2*h,_),A.set(b),A.set(w,h),A.set(_,2*h),g.position.values=A,g=function(t,e){if(!(e.normal||e.tangent||e.bitangent||e.st))return t;const a=t.position.values;let n,i;(e.normal||e.bitangent)&&(n=t.normal.values,i=t.bitangent.values);const s=t.position.values.length/18,l=3*s,d=2*s,u=2*l;let c;if(e.normal||e.bitangent||e.tangent){const s=e.normal?new Float32Array(6*l):void 0,d=e.tangent?new Float32Array(6*l):void 0,m=e.bitangent?new Float32Array(6*l):void 0;let y=D,p=V,f=N,g=P,C=I,b=O,h=u;for(c=0;c<l;c+=3){const t=h+u;y=r.Cartesian3.fromArray(a,c,y),p=r.Cartesian3.fromArray(a,c+l,p),f=r.Cartesian3.fromArray(a,(c+3)%l,f),p=r.Cartesian3.subtract(p,y,p),f=r.Cartesian3.subtract(f,y,f),g=r.Cartesian3.normalize(r.Cartesian3.cross(p,f,g),g),e.normal&&(o.CorridorGeometryLibrary.addAttribute(s,g,t),o.CorridorGeometryLibrary.addAttribute(s,g,t+3),o.CorridorGeometryLibrary.addAttribute(s,g,h),o.CorridorGeometryLibrary.addAttribute(s,g,h+3)),(e.tangent||e.bitangent)&&(b=r.Cartesian3.fromArray(n,c,b),e.bitangent&&(o.CorridorGeometryLibrary.addAttribute(m,b,t),o.CorridorGeometryLibrary.addAttribute(m,b,t+3),o.CorridorGeometryLibrary.addAttribute(m,b,h),o.CorridorGeometryLibrary.addAttribute(m,b,h+3)),e.tangent&&(C=r.Cartesian3.normalize(r.Cartesian3.cross(b,g,C),C),o.CorridorGeometryLibrary.addAttribute(d,C,t),o.CorridorGeometryLibrary.addAttribute(d,C,t+3),o.CorridorGeometryLibrary.addAttribute(d,C,h),o.CorridorGeometryLibrary.addAttribute(d,C,h+3))),h+=6}if(e.normal){for(s.set(n),c=0;c<l;c+=3)s[c+l]=-n[c],s[c+l+1]=-n[c+1],s[c+l+2]=-n[c+2];t.normal.values=s}else t.normal=void 0;if(e.bitangent?(m.set(i),m.set(i,l),t.bitangent.values=m):t.bitangent=void 0,e.tangent){const e=t.tangent.values;d.set(e),d.set(e,l),t.tangent.values=d}}if(e.st){const e=t.st.values,r=new Float32Array(6*d);r.set(e),r.set(e,d);let a=2*d;for(let t=0;t<2;t++){for(r[a++]=e[0],r[a++]=e[1],c=2;c<d;c+=2){const t=e[c],n=e[c+1];r[a++]=t,r[a++]=n,r[a++]=t,r[a++]=n}r[a++]=e[0],r[a++]=e[1]}t.st.values=r}return t}(g,e);const G=h/3;if(t.shadowVolume){const t=g.normal.values;h=t.length;let r=new Float32Array(6*h);for(v=0;v<h;v++)t[v]=-t[v];r.set(t,h),r=H(t,4*h,r),g.extrudeDirection=new d.GeometryAttribute({componentDatatype:n.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:r}),e.normal||(g.normal=void 0)}if(s.defined(t.offsetAttribute)){let e=new Uint8Array(6*G);if(t.offsetAttribute===c.GeometryOffsetAttribute.TOP)e=e.fill(1,0,G).fill(1,2*G,4*G);else{const r=t.offsetAttribute===c.GeometryOffsetAttribute.NONE?0:1;e=e.fill(r)}g.applyOffset=new d.GeometryAttribute({componentDatatype:n.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:e})}const T=C.length,E=G+G,F=m.IndexDatatype.createTypedArray(A.length/3,2*T+3*E);F.set(C);let L,x,S,M,k=T;for(v=0;v<T;v+=3){const t=C[v],e=C[v+1],r=C[v+2];F[k++]=r+G,F[k++]=e+G,F[k++]=t+G}for(v=0;v<E;v+=2)L=v+E,x=L+E,S=L+1,M=x+1,F[k++]=L,F[k++]=x,F[k++]=S,F[k++]=S,F[k++]=x,F[k++]=M;return{attributes:g,indices:F}}const U=new r.Cartesian3,Y=new r.Cartesian3,q=new r.Cartographic;function W(t,e,a,n,i,o){const s=r.Cartesian3.subtract(e,t,U);r.Cartesian3.normalize(s,s);const l=a.geodeticSurfaceNormal(t,Y),d=r.Cartesian3.cross(s,l,U);r.Cartesian3.multiplyByScalar(d,n,d);let u=i.latitude,c=i.longitude,m=o.latitude,y=o.longitude;r.Cartesian3.add(t,d,Y),a.cartesianToCartographic(Y,q);let p=q.latitude,f=q.longitude;u=Math.min(u,p),c=Math.min(c,f),m=Math.max(m,p),y=Math.max(y,f),r.Cartesian3.subtract(t,d,Y),a.cartesianToCartographic(Y,q),p=q.latitude,f=q.longitude,u=Math.min(u,p),c=Math.min(c,f),m=Math.max(m,p),y=Math.max(y,f),i.latitude=u,i.longitude=c,o.latitude=m,o.longitude=y}const j=new r.Cartesian3,J=new r.Cartesian3,K=new r.Cartographic,Q=new r.Cartographic;function X(e,a,n,o,d){e=k(e,a);const u=t.arrayRemoveDuplicates(e,r.Cartesian3.equalsEpsilon),c=u.length;if(c<2||n<=0)return new l.Rectangle;const m=.5*n;let y,p;if(K.latitude=Number.POSITIVE_INFINITY,K.longitude=Number.POSITIVE_INFINITY,Q.latitude=Number.NEGATIVE_INFINITY,Q.longitude=Number.NEGATIVE_INFINITY,o===i.CornerType.ROUNDED){const t=u[0];r.Cartesian3.subtract(t,u[1],j),r.Cartesian3.normalize(j,j),r.Cartesian3.multiplyByScalar(j,m,j),r.Cartesian3.add(t,j,J),a.cartesianToCartographic(J,q),y=q.latitude,p=q.longitude,K.latitude=Math.min(K.latitude,y),K.longitude=Math.min(K.longitude,p),Q.latitude=Math.max(Q.latitude,y),Q.longitude=Math.max(Q.longitude,p)}for(let t=0;t<c-1;++t)W(u[t],u[t+1],a,m,K,Q);const f=u[c-1];r.Cartesian3.subtract(f,u[c-2],j),r.Cartesian3.normalize(j,j),r.Cartesian3.multiplyByScalar(j,m,j),r.Cartesian3.add(f,j,J),W(f,J,a,m,K,Q),o===i.CornerType.ROUNDED&&(a.cartesianToCartographic(J,q),y=q.latitude,p=q.longitude,K.latitude=Math.min(K.latitude,y),K.longitude=Math.min(K.longitude,p),Q.latitude=Math.max(Q.latitude,y),Q.longitude=Math.max(Q.longitude,p));const g=s.defined(d)?d:new l.Rectangle;return g.north=Q.latitude,g.south=K.latitude,g.east=Q.longitude,g.west=K.longitude,g}function Z(t){const e=(t=s.defaultValue(t,s.defaultValue.EMPTY_OBJECT)).positions,a=t.width,n=s.defaultValue(t.height,0),o=s.defaultValue(t.extrudedHeight,n);this._positions=e,this._ellipsoid=l.Ellipsoid.clone(s.defaultValue(t.ellipsoid,l.Ellipsoid.WGS84)),this._vertexFormat=f.VertexFormat.clone(s.defaultValue(t.vertexFormat,f.VertexFormat.DEFAULT)),this._width=a,this._height=Math.max(n,o),this._extrudedHeight=Math.min(n,o),this._cornerType=s.defaultValue(t.cornerType,i.CornerType.ROUNDED),this._granularity=s.defaultValue(t.granularity,y.CesiumMath.RADIANS_PER_DEGREE),this._shadowVolume=s.defaultValue(t.shadowVolume,!1),this._workerName="createCorridorGeometry",this._offsetAttribute=t.offsetAttribute,this._rectangle=void 0,this.packedLength=1+e.length*r.Cartesian3.packedLength+l.Ellipsoid.packedLength+f.VertexFormat.packedLength+7}Z.pack=function(t,e,a){a=s.defaultValue(a,0);const n=t._positions,i=n.length;e[a++]=i;for(let t=0;t<i;++t,a+=r.Cartesian3.packedLength)r.Cartesian3.pack(n[t],e,a);return l.Ellipsoid.pack(t._ellipsoid,e,a),a+=l.Ellipsoid.packedLength,f.VertexFormat.pack(t._vertexFormat,e,a),a+=f.VertexFormat.packedLength,e[a++]=t._width,e[a++]=t._height,e[a++]=t._extrudedHeight,e[a++]=t._cornerType,e[a++]=t._granularity,e[a++]=t._shadowVolume?1:0,e[a]=s.defaultValue(t._offsetAttribute,-1),e};const $=l.Ellipsoid.clone(l.Ellipsoid.UNIT_SPHERE),tt=new f.VertexFormat,et={positions:void 0,ellipsoid:$,vertexFormat:tt,width:void 0,height:void 0,extrudedHeight:void 0,cornerType:void 0,granularity:void 0,shadowVolume:void 0,offsetAttribute:void 0};return Z.unpack=function(t,e,a){e=s.defaultValue(e,0);const n=t[e++],i=new Array(n);for(let a=0;a<n;++a,e+=r.Cartesian3.packedLength)i[a]=r.Cartesian3.unpack(t,e);const o=l.Ellipsoid.unpack(t,e,$);e+=l.Ellipsoid.packedLength;const d=f.VertexFormat.unpack(t,e,tt);e+=f.VertexFormat.packedLength;const u=t[e++],c=t[e++],m=t[e++],y=t[e++],p=t[e++],g=1===t[e++],C=t[e];return s.defined(a)?(a._positions=i,a._ellipsoid=l.Ellipsoid.clone(o,a._ellipsoid),a._vertexFormat=f.VertexFormat.clone(d,a._vertexFormat),a._width=u,a._height=c,a._extrudedHeight=m,a._cornerType=y,a._granularity=p,a._shadowVolume=g,a._offsetAttribute=-1===C?void 0:C,a):(et.positions=i,et.width=u,et.height=c,et.extrudedHeight=m,et.cornerType=y,et.granularity=p,et.shadowVolume=g,et.offsetAttribute=-1===C?void 0:C,new Z(et))},Z.computeRectangle=function(t,e){const r=(t=s.defaultValue(t,s.defaultValue.EMPTY_OBJECT)).positions,a=t.width;return X(r,s.defaultValue(t.ellipsoid,l.Ellipsoid.WGS84),a,s.defaultValue(t.cornerType,i.CornerType.ROUNDED),e)},Z.createGeometry=function(a){let l=a._positions;const f=a._width,g=a._ellipsoid,C=a._vertexFormat;let b;if(a._cornerType===i.CornerType.EV_ARC){if(l.length<2||f<=0)return;if(b=function(t,e,a){const i=t.positions,o=t.normals,s=new u.GeometryAttributes,l=i.length,c=new Float64Array(3*l),y=r.Cartesian3.packArray(i);c.set(y,0),s.position=new d.GeometryAttribute({componentDatatype:n.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:c});const p=3*(l-2),f=m.IndexDatatype.createTypedArray(l,p);let g,C,b,h,A=0,w=l-1,v=0,_=l/2-1;for(let t=0;t<_;t++)h=A++,b=h+1,C=w--,g=C-1,f[v++]=g,f[v++]=C,f[v++]=b,f[v++]=b,f[v++]=C,f[v++]=h;if(e.st){let t=0,e=0;const a=[];let o=I,u=O;o=r.Cartesian3.multiplyByScalar(r.Cartesian3.add(i[0],i[l-1],new r.Cartesian3),.5,o),_=l-1;for(let n=1,s=l/2;n<s;n++)u=r.Cartesian3.multiplyByScalar(r.Cartesian3.add(i[n],i[_-n],new r.Cartesian3),.5,u),t=r.Cartesian3.distance(u,o),a.push(t),e+=t,o=r.Cartesian3.clone(u);const c=new Float32Array(2*l);let m=0;c[m++]=0,c[m++]=0;let y=2*l-1;c[y--]=1,c[y--]=0,t=0;for(let r=0,n=a.length;r<n;r++){t+=a[r];const n=t/e;c[m++]=n,c[m++]=0,c[y--]=1,c[y--]=n}s.st=new d.GeometryAttribute({componentDatatype:n.ComponentDatatype.FLOAT,componentsPerAttribute:2,values:c})}if(e.normal){const t=r.Cartesian3.packArray(o),e=new Float32Array(3*l);e.set(t),s.normal=new d.GeometryAttribute({componentDatatype:n.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:e})}return{attributes:s,indices:f}}(o.CorridorGeometryLibrary.ev_computePositions({positions:l,width:f,ellipsoid:g,interpolationCount:1e3}),C),s.defined(a._offsetAttribute)){const t=a._offsetAttribute===c.GeometryOffsetAttribute.NONE?0:1,e=b.attributes.position.values.length,r=new Uint8Array(e/3).fill(t);b.attributes.applyOffset=new d.GeometryAttribute({componentDatatype:n.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:r})}}else{l=k(l,g);const e=t.arrayRemoveDuplicates(l,r.Cartesian3.equalsEpsilon);if(e.length<2||f<=0)return;const i=a._height,u=a._extrudedHeight,m=!y.CesiumMath.equalsEpsilon(i,u,0,y.CesiumMath.EPSILON2),C=a._vertexFormat,h={ellipsoid:g,positions:e,width:f,cornerType:a._cornerType,granularity:a._granularity,saveAttributes:!0};if(m)h.height=i,h.extrudedHeight=u,h.shadowVolume=a._shadowVolume,h.offsetAttribute=a._offsetAttribute,b=z(h,C);else{if(b=B(o.CorridorGeometryLibrary.computePositions(h),C,g),b.attributes.position.values=p.PolygonPipeline.scaleToGeodeticHeight(b.attributes.position.values,i,g),s.defined(a._offsetAttribute)){const t=a._offsetAttribute===c.GeometryOffsetAttribute.NONE?0:1,e=b.attributes.position.values.length,r=new Uint8Array(e/3).fill(t);b.attributes.applyOffset=new d.GeometryAttribute({componentDatatype:n.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:r})}}}const h=b.attributes,A=e.BoundingSphere.fromVertices(h.position.values,void 0,3);return C.position||(b.attributes.position.values=void 0),new d.Geometry({attributes:h,indices:b.indices,primitiveType:d.PrimitiveType.TRIANGLES,boundingSphere:A,offsetAttribute:a._offsetAttribute})},Z.createShadowVolume=function(t,e,r){const a=t._granularity,n=t._ellipsoid,i=e(a,n),o=r(a,n);return new Z({positions:t._positions,width:t._width,cornerType:t._cornerType,ellipsoid:n,granularity:a,extrudedHeight:i,height:o,vertexFormat:f.VertexFormat.POSITION_ONLY,shadowVolume:!0})},Object.defineProperties(Z.prototype,{rectangle:{get:function(){return s.defined(this._rectangle)||(this._rectangle=X(this._positions,this._ellipsoid,this._width,this._cornerType)),this._rectangle}},textureCoordinateRotationPoints:{get:function(){return[0,0,0,1,1,0]}}}),function(t,e){return s.defined(e)&&(t=Z.unpack(t,e)),t._ellipsoid=l.Ellipsoid.clone(t._ellipsoid),Z.createGeometry(t)}}));
