/**
 * @license
 * Cesium - https://github.com/CesiumGS/cesium
 * Version 1.96
 *
 * Copyright 2011-2022 Cesium Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Columbus View (Pat. Pend.)
 *
 * Portions licensed separately.
 * See https://github.com/CesiumGS/cesium/blob/main/LICENSE.md for full licensing details.
 */
define(["./AttributeCompression-055d015a","./Matrix4-d3db9505","./Color-151cb095","./defined-b681f02d","./Rectangle-0610a1c7","./IndexDatatype-1b44a4e6","./Math-5b6faca9","./OrientedBoundingBox-4ee28786","./createTaskProcessorWorker","./ComponentDatatype-46a1cf7a","./Check-436535f3","./WebGLConstants-f100e3dd","./Matrix2-7384588e","./RuntimeError-14317824","./Transforms-99c89742","./Interval-49d6e8fc","./_commonjsHelpers-a32ac251","./combine-8b9ba6cb","./RequestType-e53aab71","./EllipsoidTangentPlane-34e5c0ac","./AxisAlignedBoundingBox-321a482b","./IntersectionTests-3ac7f0c9","./Plane-172c23d7"],(function(e,t,n,a,r,o,s,i,c,f,d,l,u,h,g,p,b,m,y,C,I,x,w){"use strict";const A=new t.Cartesian3,T=new r.Ellipsoid,E=new r.Rectangle,N={min:void 0,max:void 0,indexBytesPerElement:void 0};function k(e,t,a){const r=t.length,o=2+r*i.OrientedBoundingBox.packedLength+1+function(e){const t=e.length;let a=0;for(let r=0;r<t;++r)a+=n.Color.packedLength+3+e[r].batchIds.length;return a}(a),s=new Float64Array(o);let c=0;s[c++]=e,s[c++]=r;for(let e=0;e<r;++e)i.OrientedBoundingBox.pack(t[e],s,c),c+=i.OrientedBoundingBox.packedLength;const f=a.length;s[c++]=f;for(let e=0;e<f;++e){const t=a[e];n.Color.pack(t.color,s,c),c+=n.Color.packedLength,s[c++]=t.offset,s[c++]=t.count;const r=t.batchIds,o=r.length;s[c++]=o;for(let e=0;e<o;++e)s[c++]=r[e]}return s}const B=new t.Cartesian3,L=new t.Cartesian3,O=new t.Cartesian3,U=new t.Cartesian3,P=new t.Cartesian3,R=new t.Cartographic,F=new r.Rectangle;return c((function(c,f){let d;!function(e){const n=new Float64Array(e);let a=0;N.indexBytesPerElement=n[a++],N.min=n[a++],N.max=n[a++],t.Cartesian3.unpack(n,a,A),a+=t.Cartesian3.packedLength,r.Ellipsoid.unpack(n,a,T),a+=r.Ellipsoid.packedLength,r.Rectangle.unpack(n,a,E)}(c.packedBuffer),d=2===N.indexBytesPerElement?new Uint16Array(c.indices):new Uint32Array(c.indices);const l=new Uint16Array(c.positions),u=new Uint32Array(c.counts),h=new Uint32Array(c.indexCounts),g=new Uint32Array(c.batchIds),p=new Uint32Array(c.batchTableColors),b=new Array(u.length),m=A,y=T;let C=E;const I=N.min,x=N.max;let w,M,S,D=c.minimumHeights,_=c.maximumHeights;a.defined(D)&&a.defined(_)&&(D=new Float32Array(D),_=new Float32Array(_));const G=l.length/2,Y=l.subarray(0,G),v=l.subarray(G,2*G);e.AttributeCompression.zigZagDeltaDecode(Y,v);const H=new Float64Array(3*G);for(w=0;w<G;++w){const e=Y[w],n=v[w],a=s.CesiumMath.lerp(C.west,C.east,e/32767),r=s.CesiumMath.lerp(C.south,C.north,n/32767),o=t.Cartographic.fromRadians(a,r,0,R),i=y.cartographicToCartesian(o,B);t.Cartesian3.pack(i,H,3*w)}const V=u.length,W=new Array(V),j=new Array(V);let q=0,z=0;for(w=0;w<V;++w)W[w]=q,j[w]=z,q+=u[w],z+=h[w];const Z=new Float32Array(3*G*2),J=new Uint16Array(2*G),K=new Uint32Array(j.length),Q=new Uint32Array(h.length);let X=[];const $={};for(w=0;w<V;++w)S=p[w],a.defined($[S])?($[S].positionLength+=u[w],$[S].indexLength+=h[w],$[S].batchIds.push(w)):$[S]={positionLength:u[w],indexLength:h[w],offset:0,indexOffset:0,batchIds:[w]};let ee,te=0,ne=0;for(S in $)if($.hasOwnProperty(S)){ee=$[S],ee.offset=te,ee.indexOffset=ne;const e=2*ee.positionLength,t=2*ee.indexLength+6*ee.positionLength;te+=e,ne+=t,ee.indexLength=t}const ae=[];for(S in $)$.hasOwnProperty(S)&&(ee=$[S],ae.push({color:n.Color.fromRgba(parseInt(S)),offset:ee.indexOffset,count:ee.indexLength,batchIds:ee.batchIds}));for(w=0;w<V;++w){S=p[w],ee=$[S];const e=ee.offset;let n=3*e,r=e;const o=W[w],s=u[w],c=g[w];let f=I,l=x;a.defined(D)&&a.defined(_)&&(f=D[w],l=_[w]);let A=Number.POSITIVE_INFINITY,T=Number.NEGATIVE_INFINITY,E=Number.POSITIVE_INFINITY,N=Number.NEGATIVE_INFINITY;for(M=0;M<s;++M){const e=t.Cartesian3.unpack(H,3*o+3*M,B);y.scaleToGeodeticSurface(e,e);const a=y.cartesianToCartographic(e,R),s=a.latitude,i=a.longitude;A=Math.min(s,A),T=Math.max(s,T),E=Math.min(i,E),N=Math.max(i,N);const d=y.geodeticSurfaceNormal(e,L);let u=t.Cartesian3.multiplyByScalar(d,f,O);const h=t.Cartesian3.add(e,u,U);u=t.Cartesian3.multiplyByScalar(d,l,u);const g=t.Cartesian3.add(e,u,P);t.Cartesian3.subtract(g,m,g),t.Cartesian3.subtract(h,m,h),t.Cartesian3.pack(g,Z,n),t.Cartesian3.pack(h,Z,n+3),J[r]=c,J[r+1]=c,n+=6,r+=2}C=F,C.west=E,C.east=N,C.south=A,C.north=T,b[w]=i.OrientedBoundingBox.fromRectangle(C,I,x,y);let k=ee.indexOffset;const G=j[w],Y=h[w];for(K[w]=k,M=0;M<Y;M+=3){const t=d[G+M]-o,n=d[G+M+1]-o,a=d[G+M+2]-o;X[k++]=2*t+e,X[k++]=2*n+e,X[k++]=2*a+e,X[k++]=2*a+1+e,X[k++]=2*n+1+e,X[k++]=2*t+1+e}for(M=0;M<s;++M){const t=M,n=(M+1)%s;X[k++]=2*t+1+e,X[k++]=2*n+e,X[k++]=2*t+e,X[k++]=2*t+1+e,X[k++]=2*n+1+e,X[k++]=2*n+e}ee.offset+=2*s,ee.indexOffset=k,Q[w]=k-K[w]}X=o.IndexDatatype.createTypedArray(Z.length/3,X);const re=ae.length;for(let e=0;e<re;++e){const t=ae[e].batchIds;let n=0;const a=t.length;for(let e=0;e<a;++e)n+=Q[t[e]];ae[e].count=n}const oe=k(2===X.BYTES_PER_ELEMENT?o.IndexDatatype.UNSIGNED_SHORT:o.IndexDatatype.UNSIGNED_INT,b,ae);return f.push(Z.buffer,X.buffer,K.buffer,Q.buffer,J.buffer,oe.buffer),{positions:Z.buffer,indices:X.buffer,indexOffsets:K.buffer,indexCounts:Q.buffer,batchIds:J.buffer,packedBuffer:oe.buffer}}))}));
