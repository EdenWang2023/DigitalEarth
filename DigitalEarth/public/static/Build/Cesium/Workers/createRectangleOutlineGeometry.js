/**
 * @license
 * Cesium - https://github.com/CesiumGS/cesium
 * Version 1.96
 *
 * Copyright 2011-2022 Cesium Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Columbus View (Pat. Pend.)
 *
 * Portions licensed separately.
 * See https://github.com/CesiumGS/cesium/blob/main/LICENSE.md for full licensing details.
 */
define(["./defined-b681f02d","./Rectangle-0610a1c7","./Transforms-99c89742","./Matrix4-d3db9505","./ComponentDatatype-46a1cf7a","./Check-436535f3","./GeometryAttribute-ef6ca9ab","./GeometryAttributes-18ccc0d6","./GeometryOffsetAttribute-3e5f3e97","./IndexDatatype-1b44a4e6","./Math-5b6faca9","./PolygonPipeline-5a6c6b44","./RectangleGeometryLibrary-516291fd","./Interval-49d6e8fc","./_commonjsHelpers-a32ac251","./combine-8b9ba6cb","./RequestType-e53aab71","./RuntimeError-14317824","./WebGLConstants-f100e3dd","./Matrix2-7384588e","./EllipsoidRhumbLine-65d4aeca"],(function(e,t,i,n,o,a,r,l,s,u,c,p,d,f,g,h,y,m,b,_,E){"use strict";const A=new i.BoundingSphere,G=new i.BoundingSphere,R=new n.Cartesian3,P=new t.Rectangle;function v(e,t){const i=e._ellipsoid,n=t.height,a=t.width,s=t.northCap,c=t.southCap;let p=n,f=2,g=0,h=4;s&&(f-=1,p-=1,g+=1,h-=2),c&&(f-=1,p-=1,g+=1,h-=2),g+=f*a+2*p-h;const y=new Float64Array(3*g);let m,b=0,_=0;const E=R;if(s)d.RectangleGeometryLibrary.computePosition(t,i,!1,_,0,E),y[b++]=E.x,y[b++]=E.y,y[b++]=E.z;else for(m=0;m<a;m++)d.RectangleGeometryLibrary.computePosition(t,i,!1,_,m,E),y[b++]=E.x,y[b++]=E.y,y[b++]=E.z;for(m=a-1,_=1;_<n;_++)d.RectangleGeometryLibrary.computePosition(t,i,!1,_,m,E),y[b++]=E.x,y[b++]=E.y,y[b++]=E.z;if(_=n-1,!c)for(m=a-2;m>=0;m--)d.RectangleGeometryLibrary.computePosition(t,i,!1,_,m,E),y[b++]=E.x,y[b++]=E.y,y[b++]=E.z;for(m=0,_=n-2;_>0;_--)d.RectangleGeometryLibrary.computePosition(t,i,!1,_,m,E),y[b++]=E.x,y[b++]=E.y,y[b++]=E.z;const A=y.length/3*2,G=u.IndexDatatype.createTypedArray(y.length/3,A);let P=0;for(let e=0;e<y.length/3-1;e++)G[P++]=e,G[P++]=e+1;G[P++]=y.length/3-1,G[P++]=0;const v=new r.Geometry({attributes:new l.GeometryAttributes,primitiveType:r.PrimitiveType.LINES});return v.attributes.position=new r.GeometryAttribute({componentDatatype:o.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:y}),v.indices=G,v}function L(i){const n=(i=e.defaultValue(i,e.defaultValue.EMPTY_OBJECT)).rectangle,o=e.defaultValue(i.granularity,c.CesiumMath.RADIANS_PER_DEGREE),a=e.defaultValue(i.ellipsoid,t.Ellipsoid.WGS84),r=e.defaultValue(i.rotation,0),l=e.defaultValue(i.height,0),s=e.defaultValue(i.extrudedHeight,l);this._rectangle=t.Rectangle.clone(n),this._granularity=o,this._ellipsoid=a,this._surfaceHeight=Math.max(l,s),this._rotation=r,this._extrudedHeight=Math.min(l,s),this._offsetAttribute=i.offsetAttribute,this._workerName="createRectangleOutlineGeometry"}L.packedLength=t.Rectangle.packedLength+t.Ellipsoid.packedLength+5,L.pack=function(i,n,o){return o=e.defaultValue(o,0),t.Rectangle.pack(i._rectangle,n,o),o+=t.Rectangle.packedLength,t.Ellipsoid.pack(i._ellipsoid,n,o),o+=t.Ellipsoid.packedLength,n[o++]=i._granularity,n[o++]=i._surfaceHeight,n[o++]=i._rotation,n[o++]=i._extrudedHeight,n[o]=e.defaultValue(i._offsetAttribute,-1),n};const w=new t.Rectangle,C=t.Ellipsoid.clone(t.Ellipsoid.UNIT_SPHERE),x={rectangle:w,ellipsoid:C,granularity:void 0,height:void 0,rotation:void 0,extrudedHeight:void 0,offsetAttribute:void 0};L.unpack=function(i,n,o){n=e.defaultValue(n,0);const a=t.Rectangle.unpack(i,n,w);n+=t.Rectangle.packedLength;const r=t.Ellipsoid.unpack(i,n,C);n+=t.Ellipsoid.packedLength;const l=i[n++],s=i[n++],u=i[n++],c=i[n++],p=i[n];return e.defined(o)?(o._rectangle=t.Rectangle.clone(a,o._rectangle),o._ellipsoid=t.Ellipsoid.clone(r,o._ellipsoid),o._surfaceHeight=s,o._rotation=u,o._extrudedHeight=c,o._offsetAttribute=-1===p?void 0:p,o):(x.granularity=l,x.height=s,x.rotation=u,x.extrudedHeight=c,x.offsetAttribute=-1===p?void 0:p,new L(x))};const D=new n.Cartographic;return L.createGeometry=function(t){const n=t._rectangle,a=t._ellipsoid,l=d.RectangleGeometryLibrary.computeOptions(n,t._granularity,t._rotation,0,P,D);let f,g;if(c.CesiumMath.equalsEpsilon(n.north,n.south,c.CesiumMath.EPSILON10)||c.CesiumMath.equalsEpsilon(n.east,n.west,c.CesiumMath.EPSILON10))return;const h=t._surfaceHeight,y=t._extrudedHeight;let m;if(!c.CesiumMath.equalsEpsilon(h,y,0,c.CesiumMath.EPSILON2)){if(f=function(e,t){const i=e._surfaceHeight,n=e._extrudedHeight,o=e._ellipsoid,a=n,r=i,l=v(e,t),s=t.height,c=t.width,d=p.PolygonPipeline.scaleToGeodeticHeight(l.attributes.position.values,r,o,!1);let f=d.length;const g=new Float64Array(2*f);g.set(d);const h=p.PolygonPipeline.scaleToGeodeticHeight(l.attributes.position.values,a,o);g.set(h,f),l.attributes.position.values=g;const y=t.northCap,m=t.southCap;let b=4;y&&(b-=1),m&&(b-=1);const _=2*(g.length/3+b),E=u.IndexDatatype.createTypedArray(g.length/3,_);f=g.length/6;let A,G=0;for(let e=0;e<f-1;e++)E[G++]=e,E[G++]=e+1,E[G++]=e+f,E[G++]=e+f+1;if(E[G++]=f-1,E[G++]=0,E[G++]=f+f-1,E[G++]=f,E[G++]=0,E[G++]=f,y)A=s-1;else{const e=c-1;E[G++]=e,E[G++]=e+f,A=c+s-2}if(E[G++]=A,E[G++]=A+f,!m){const e=c+A-1;E[G++]=e,E[G]=e+f}return l.indices=E,l}(t,l),e.defined(t._offsetAttribute)){const e=f.attributes.position.values.length/3;let i=new Uint8Array(e);t._offsetAttribute===s.GeometryOffsetAttribute.TOP?i=i.fill(1,0,e/2):(m=t._offsetAttribute===s.GeometryOffsetAttribute.NONE?0:1,i=i.fill(m)),f.attributes.applyOffset=new r.GeometryAttribute({componentDatatype:o.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:i})}const c=i.BoundingSphere.fromRectangle3D(n,a,h,G),d=i.BoundingSphere.fromRectangle3D(n,a,y,A);g=i.BoundingSphere.union(c,d)}else{if(f=v(t,l),f.attributes.position.values=p.PolygonPipeline.scaleToGeodeticHeight(f.attributes.position.values,h,a,!1),e.defined(t._offsetAttribute)){const e=f.attributes.position.values.length;m=t._offsetAttribute===s.GeometryOffsetAttribute.NONE?0:1;const i=new Uint8Array(e/3).fill(m);f.attributes.applyOffset=new r.GeometryAttribute({componentDatatype:o.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:i})}g=i.BoundingSphere.fromRectangle3D(n,a,h)}return new r.Geometry({attributes:f.attributes,indices:f.indices,primitiveType:r.PrimitiveType.LINES,boundingSphere:g,offsetAttribute:t._offsetAttribute})},function(i,n){return e.defined(n)&&(i=L.unpack(i,n)),i._ellipsoid=t.Ellipsoid.clone(i._ellipsoid),i._rectangle=t.Rectangle.clone(i._rectangle),L.createGeometry(i)}}));
